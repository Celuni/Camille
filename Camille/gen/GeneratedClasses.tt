<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="$(ProjectDir)gen\Chsword.JDynamic.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Chsword" #>
<#@ import namespace="Microsoft.CSharp.RuntimeBinder" #>
<#@ output extension=".cs" #>
<#
    dynamic spec = new JDynamic(File.ReadAllText(Host.ResolvePath(".spec.json")));
#>
// This file is automatically generated.
// Do not directly edit.
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version <#= spec.info.version #>
// Generated on <#= GetTimestamp() #>

using System.Collections.Generic;
using System.Threading.Tasks;
using Newtonsoft.Json;
using MingweiSamuel.Camille.Enums;

#region methods
namespace MingweiSamuel.Camille
{
<#
    IDictionary<string, dynamic> pathsDict = DynamicToDict(spec.paths);
    var endpointGroups = pathsDict
        .GroupBy(kvp => (string) GetDynamicMember(kvp.Value, "x-endpoint")).ToList();
#>
<# // RiotApi Class // #>
    public partial class RiotApi
    {
<#
    foreach (var endpointMethods in endpointGroups)
    {
        var endpoint = NormalizeEndpointName(endpointMethods.Key);
#>
        public readonly <#= endpoint #>Endpoints <#= endpoint #>;
<#
    }
#>

        private RiotApi()
        {
<#
    foreach (var endpointMethods in endpointGroups)
    {
        var endpoint = NormalizeEndpointName(endpointMethods.Key);
#>
            <#= endpoint #> = new <#= endpoint #>Endpoints(this);
<#
    }
#>
        }
    }

<# // Endpoint Classes // #>
<#
    foreach (var endpointMethods in endpointGroups)
    {
        var endpoint = NormalizeEndpointName(endpointMethods.Key);
#>
    // <#= endpointMethods.Key #>
    public class <#= endpoint #>Endpoints : Endpoints
    {
        internal <#= endpoint #>Endpoints(RiotApi riotApi) : base(riotApi)
        {}

<#
        foreach (var keyValuePair in endpointMethods)
        {
            var route = keyValuePair.Key;
            var path = keyValuePair.Value;
            var get = GetDynamicMember(path, "get");
            if (null == get)
                continue;
            string operationId = get.operationId;
            var method = Capitalize(operationId.Substring(operationId.IndexOf('.') + 1));

            var responses = get.responses;
            var response200 = GetDynamicMember(responses, "200");
            var jsonInfo = GetDynamicMember(response200.content, "application/json");
            string returnType = StringifyType(jsonInfo.schema, endpoint);

            // Cases if not rate limited.
            bool rateLimitExcluded = GetDynamicMember(get, "x-app-rate-limit-excluded") ?? false;

            // Description processing.
            string desc = get.description;
            var descArr = Regex
                .Replace(desc, @"(#+)\s*([^\\]+)\\n(.*?)([\\n$])", m =>
                    $"<h{m.Groups[1].Length}>{m.Groups[2]}</h{m.Groups[1].Length}>\\n{m.Groups[3]}{m.Groups[4]}")
                .Split(new [] {@"\n"}, StringSplitOptions.None);

            // Build argument comment & string.
            var argBuilder = new StringBuilder();
            var makeParamCode = "";
            dynamic[] allParams = GetDynamicMember(get, "parameters");
            if (null != allParams && allParams.Length > 0)
            {
                var pathParams = allParams.Where(p => "path" == GetDynamicMember(p, "in"))
                    .OrderBy(p => route.IndexOf(p.name)).ToList();
                var reqParams = allParams.Where(p => "path" != GetDynamicMember(p, "in") && p.required).ToList();
                var optParams = allParams.Where(p => "path" != GetDynamicMember(p, "in") && !p.required)
                    .OrderBy(p =>
                        string.Join("", Regex.Matches((string) p.name, "(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+)")
                            .OfType<Match>()
                            .Select(m => m.Value)
                            .Reverse())
                    ).ToList();
                foreach (var paramList in new[] {pathParams, reqParams, optParams})
                {
                    var required = ReferenceEquals(paramList, pathParams);
                    foreach (var param in paramList)
                    {
                        argBuilder.Append(", ")
                            .Append(StringifyType(param.schema, endpoint, !required))
                            .Append(' ').Append(param.name);
                        if (!required)
                            argBuilder.Append(" = null");
                    }
                }
                makeParamCode = string.Join(", ", reqParams.Concat(optParams)
                    .Select(p => p.name)
                    .SelectMany(n => new[] {$"nameof({n})", n}));
            }

            foreach (var async in new[] {"", "Async"})
            {
#>
        /// <summary>
<#
                foreach (var descLine in descArr)
                {
#>
        /// <#= descLine #><br />
<#
                }
#>
        /// <br />
        /// <a href="<#= get.externalDocs.url #>"><#= get.externalDocs.description #></a>
        /// </summary>
        /// <param name="region">Region to query.</param>
<#
            if (null != allParams)
                {
                    foreach (var param in allParams)
                    {
#>
        /// <param name="<#= param.name #>"><#= GetDynamicMember(param, "description") ?? "" #> (<#= param.required ? "required" : "optional" #>)></param>
<#
                    }
                }
#>
        public <#= "Async" == async ? $"Task<{returnType}>" : returnType #> <#= method #><#= async #>(Region region<#= argBuilder #>)
        {
            return RiotApi.Get<#= async #><<#= returnType #>>("<#= operationId #>", $"<#= route #>",
                region, MakeParams(<#= makeParamCode #>), <#= rateLimitExcluded.ToString().ToLowerInvariant() #>);
        }

<#
            }
        }
#>
    }
<#
    }
#>
}
#endregion

#region data objects
<# // DTOs // #>
<#
    var schemas = spec.components.schemas;
    foreach (string schemaKey in GetKeys(schemas))
    {
        if ("Error".Equals(schemaKey))
        {
            continue;
        }
        var schemaSplit = schemaKey.Split('.');
        var endpoint = schemaSplit[0];
        var schemaName = NormailzeSchemaName(schemaSplit[1]);
        var schema = GetDynamicMember(schemas, schemaKey);
        IDictionary<string, dynamic> props = DynamicToDict(schema.properties);
#>
// <#= endpoint #>
namespace MingweiSamuel.Camille.<#= NormalizeEndpointName(endpoint) #>
{
<#
        string desc = GetDynamicMember(schema, "description");
        if (desc != null)
            WriteLine("    /// " + desc);
#>
    public class <#= schemaName #>
    {
        public <#= schemaName #>(<#= string.Join(",\r\n                ", props.Select(kv => GetJsonProperty(kv.Key) + ' ' +
            StringifyType(kv.Value) + ' ' + NormalizeArgName(kv.Key))) #>) {
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            if (name.Equals(schemaName))
                name += StringifyType(propKv.Value);
            var argName = NormalizeArgName(propKv.Key);
            var thiz = argName.Equals(name) ? "this." : "";
            WriteLine($"            {thiz}{name} = {argName};");
        }
#>
        }
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            var prop = propKv.Value;
#>
        <#= GetJsonProperty(propKv.Key) #>
        public readonly <#= StringifyType(prop) #> <#= name #>;
<#
        }
#>

        public override string ToString()
        {
            return $"{{ <#= string.Join(", ", props.Select(kv => NormalizePropName(kv.Key, schemaName, kv.Value)).Select(n => $"{n}: {{{n}}}")) #> }}";
        }
    }
}

<#
    }
#>
#endregion
<#@ include file="$(ProjectDir)\gen\Utils.t4" #>
