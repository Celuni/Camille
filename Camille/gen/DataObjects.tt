<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="$(SolutionDir)Camille\gen\Chsword.JDynamic.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Chsword" #>
<#@ import namespace="Microsoft.CSharp.RuntimeBinder" #>
<#@ output extension=".cs" #>
<#
    dynamic spec = new JDynamic(File.ReadAllText(Host.ResolvePath(".spec.json")));
#>
// This file is automatically generated.
// Do not directly edit.
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version <#= spec.info.version #>

using System.Collections.Generic;
using System.Threading.Tasks;
using Newtonsoft.Json;
using MingweiSamuel.Camille.Enums;

#region methods
namespace MingweiSamuel.Camille
{
<#
    IDictionary<string, dynamic> pathsDict = DynamicToDict(spec.paths);
    foreach (var endpointMethods in pathsDict
        .GroupBy(kvp => NormalizeEndpointName((string) GetDynamicMember(kvp.Value, "x-endpoint"))))
    {
        var endpoint = endpointMethods.Key;
#>
    // <#= endpoint #>
    public class <#= endpoint #>Endpoints : Endpoints
    {
        internal <#= endpoint #>Endpoints(RiotApi riotApi) : base(riotApi)
        {}
<#
        foreach (var keyValuePair in endpointMethods)
        {
            var route = keyValuePair.Key;
            var path = keyValuePair.Value;
            var get = GetDynamicMember(path, "get");
            if (null == get)
                continue;
            string operationId = get.operationId;
            var method = Capitalize(operationId.Substring(operationId.IndexOf('.') + 1));

            var responses = get.responses;
            var response200 = GetDynamicMember(responses, "200");
            var jsonInfo = GetDynamicMember(response200.content, "application/json");
            string returnType = StringifyType(jsonInfo.schema, endpoint);

            // Cases if not rate limited.
            bool rateLimitExcluded = GetDynamicMember(get, "x-app-rate-limit-excluded") ?? false;
            var rateLimitString = rateLimitExcluded ? "NonRateLimited" : "";

            // Description processing.
            string desc = get.description;
            var descArr = Regex
                .Replace(desc, @"(#+)\s*([^\\]+)\\n(.*?)([\\n$])", m =>
                    $"<h{m.Groups[1].Length}>{m.Groups[2]}</h{m.Groups[1].Length}>\\n{m.Groups[3]}{m.Groups[4]}")
                .Split(new [] {@"\n"}, StringSplitOptions.None);

            // Build argument comment & string.
            var argBuilder = new StringBuilder();
            var makeParamCode = "";
            dynamic[] allParams = GetDynamicMember(get, "parameters");
            if (null != allParams && allParams.Length > 0)
            {
                var pathParams = allParams.Where(p => "path" == GetDynamicMember(p, "in")).ToList();
                var reqParams = allParams.Where(p => "path" != GetDynamicMember(p, "in") && p.required).ToList();
                var optParams = allParams.Where(p => "path" != GetDynamicMember(p, "in") && !p.required).ToList();
                foreach (var paramList in new[] {pathParams, reqParams, optParams})
                {
                    var required = ReferenceEquals(paramList, pathParams);
                    foreach (var param in paramList)
                    {
                        argBuilder.Append(", ")
                            .Append(StringifyType(param.schema, endpoint, !required))
                            .Append(' ').Append(param.name);
                        if (!required)
                            argBuilder.Append(" = null");
                    }
                }
                makeParamCode = string.Join(", ", reqParams.Concat(optParams)
                    .Select(p => p.name)
                    .SelectMany(n => new[] {$"nameof({n})", n}));
            }

            foreach (var async in new[] {"", "Async"})
            {
#>

        /// <summary>
<#
                foreach (var descLine in descArr)
                {
#>
        /// <#= descLine #><br />
<#
                }
#>
        /// <br />
        /// <a href="<#= get.externalDocs.url #>"><#= get.externalDocs.description #></a>
        /// </summary>
        /// <param name="region">Region to query.</param>
<#
            if (null != allParams)
                {
                    foreach (var param in allParams)
                    {
#>
        /// <param name="<#= param.name #>"><#= GetDynamicMember(param, "description") ?? "" #> (<#= param.required ? "required" : "optional" #>)></param>
<#
                    }
                }
#>
        public <#= "Async" == async ? $"Task<{returnType}>" : returnType #> <#= method #><#= async #>(Region region<#= argBuilder #>)
        {
            return RiotApi.Get<#= rateLimitString #><#= async #><<#= returnType #>>("<#= operationId #>", $"<#= route #>",
                region, MakeParams(<#= makeParamCode #>));
        }

<#
            }
        }
#>
    }
<#
    }
#>
}
#endregion

#region data objects
<#
    var schemas = spec.components.schemas;
    foreach (string schemaKey in GetKeys(schemas))
    {
        if ("Error".Equals(schemaKey))
        {
            continue;
        }
        var schemaSplit = schemaKey.Split('.');
        var endpoint = schemaSplit[0];
        var schemaName = NormailzeSchemaName(schemaSplit[1]);
        var schema = GetDynamicMember(schemas, schemaKey);
        IDictionary<string, dynamic> props = DynamicToDict(schema.properties);
#>
// <#= endpoint #>
namespace MingweiSamuel.Camille.<#= NormalizeEndpointName(endpoint) #>
{
<#
        string desc = GetDynamicMember(schema, "description");
        if (desc != null)
            WriteLine("    /// " + desc);
#>
    public struct <#= schemaName #>
    {
        public <#= schemaName #>(<#= string.Join(",\r\n                ", props.Select(kv => GetJsonProperty(kv.Key) + ' ' +
            StringifyType(kv.Value) + ' ' + NormalizeArgName(kv.Key))) #>) {
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            if (name.Equals(schemaName))
                name += StringifyType(propKv.Value);
            var argName = NormalizeArgName(propKv.Key);
            var thiz = argName.Equals(name) ? "this." : "";
            WriteLine($"            {thiz}{name} = {argName};");
        }
#>
        }
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            var prop = propKv.Value;
#>
        <#= GetJsonProperty(propKv.Key) #>
        public readonly <#= StringifyType(prop) #> <#= name #>;
<#
        }
#>
    }
}

<#
    }
#>
#endregion
<#+
    public static string StringifyType(dynamic prop, string endpoint = null, bool nullable = false)
    {
        var anyOf = GetDynamicMember(prop, "anyOf");
        if (anyOf != null)
        {
            prop = anyOf[0];
        }

        string refType = GetDynamicMember(prop, "$ref");
        if (refType != null)
        {
            return (null == endpoint ? "" : endpoint + '.') + 
                NormailzeSchemaName(refType.Substring(refType.IndexOf('.') + 1));
        }
        var qm = nullable ? "?" : "";
        switch ((string) prop.type)
        {
            case "boolean": return "bool" + qm;
            case "integer": return ("int32".Equals(prop.format) ? "int" : "long") + qm;
            case "number": return prop.format + qm;
            case "array": return StringifyType(prop.items, endpoint) + "[]";
            case "object":
                return "IDictionary<" + StringifyType(GetDynamicMember(prop, "x-key"), endpoint) + ", " +
                    StringifyType(prop.additionalProperties, endpoint) + ">";
            default: return prop.type;
        }
    }

    private static string Capitalize(string input)
    {
        return input.First().ToString().ToUpper() + input.Substring(1);
    }

    private static string Decapitalize(string input)
    {
        return input.First().ToString().ToLower() + input.Substring(1);
    }

    private static string GetJsonProperty(string name)
    {
        return $"[JsonProperty(\"{name}\")]";
    }

    private static string NormalizeArgName(string name)
    {
        var tokens = name.Split('_');
        var argName = Decapitalize(string.Join("", tokens.Select(Capitalize)));
        if ("base".Equals(argName))
            return "Base";
        return argName;
    }

    private static string NormalizePropName(string propName, string schemaName, object value)
    {
        var tokens = propName.Split('_');
        var name = string.Join("", tokens.Select(Capitalize));
        if (name.Equals(schemaName))
            name += StringifyType(value);
        return name;
    }

    private static string NormalizeEndpointName(string name)
    {
        var tokens = name.Split('-');
        return string.Join("", tokens
            .Take(tokens.Length - 1)
            .Select(Capitalize));
    }

    private static string NormailzeSchemaName(string name)
    {
        return Regex.Replace(name, @"DTO", "", RegexOptions.IgnoreCase);
    }

    private static IDictionary<string, dynamic> DynamicToDict(JDynamic obj)
    {
        return GetKeys(obj).ToDictionary(k => k, k => GetDynamicMember(obj, k));
    }

    private static ICollection<string> GetKeys(JDynamic obj)
    {
        return ((IDictionary<string, object>) obj.Value).Keys;
    }

    private static object GetDynamicMember(object obj, string memberName)
    {
        var type = obj.GetType();
        var binder = Binder.GetMember(CSharpBinderFlags.None, memberName, type,
            new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) });
        var callsite = CallSite<Func<CallSite, object, object>>.Create(binder);
        try
        {
            return callsite.Target(callsite, obj);
        }
        catch (RuntimeBinderException)
        {
            return null;
        }
    }
#>
