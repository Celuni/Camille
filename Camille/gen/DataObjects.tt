<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="$(SolutionDir)Camille\gen\Chsword.JDynamic.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Dynamic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Chsword" #>
<#@ import namespace="Microsoft.CSharp.RuntimeBinder" #>
<#@ output extension=".cs" #>
<#
    dynamic spec = new JDynamic(File.ReadAllText(Host.ResolvePath(".spec.json")));
    var schemas = spec.components.schemas;
#>
// This file is automatically generated.
// Do not directly edit.
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version <#= spec.info.version #>

using System.Collections.Generic;

#region data objects
<#
    foreach (string schemaKey in GetKeys(schemas))
    {
        if ("Error".Equals(schemaKey))
        {
            continue;
        }
        var schemaSplit = schemaKey.Split('.');
        var endpoint = schemaSplit[0];
        var schemaName = NormailzeSchemaName(schemaSplit[1]);
        var schema = GetDynamicMember(schemas, schemaKey);
#>

// <#= endpoint #>
namespace MingweiSamuel.Camille.<#= NormalizeEndpointName(endpoint) #>
{
<#
        string desc = GetDynamicMember(schema, "description");
        if (desc != null)
            WriteLine("    /// " + desc);
#>
    public struct <#= schemaName #>
    {
<#
        foreach (string propName in GetKeys(schema.properties))
        {
            var prop = GetDynamicMember(schema.properties, propName);
#>
        public <#= StringifyType(prop) #> <#= NormalizePropName(propName) #>;
<#
        }
#>
    }
}
<#
    }
#>
#endregion
<#+
    private static ICollection<string> GetKeys(JDynamic obj)
    {
        return ((IDictionary<string, object>) obj.Value).Keys;
    }

    public static string StringifyType(dynamic prop)
    {
        var anyOf = GetDynamicMember(prop, "anyOf");
        if (anyOf != null)
        {
            prop = anyOf[0];
        }

        string refType = GetDynamicMember(prop, "$ref");
        if (refType != null)
        {
            return NormailzeSchemaName(refType.Substring(refType.IndexOf('.') + 1));
        }
        switch ((string) prop.type)
        {
            case "boolean": return "bool";
            case "integer": return prop.format == "int32" ? "int" : "long";
            case "number": return prop.format;
            case "array": return StringifyType(prop.items) + "[]";
            case "object":
                return "IDictionary<" + StringifyType(GetDynamicMember(prop, "x-key")) + ", " +
                    StringifyType(prop.additionalProperties) + ">";
            default: return prop.type;
        }
    }

    private static string Capitalize(string input)
    {
        return input.First().ToString().ToUpper() + input.Substring(1);
    }

    private static string NormalizePropName(string name)
    {
        var tokens = name.Split('_');
        return string.Join("", tokens.Select(Capitalize));
    }

    private static string NormalizeEndpointName(string name)
    {
        var tokens = name.Split('-');
        return string.Join("", tokens
            .Take(tokens.Length - 1)
            .Select(Capitalize));
    }

    private static string NormailzeSchemaName(string name)
    {
        return Regex.Replace(name, @"DTO$", "");
    }

    private static object GetDynamicMember(object obj, string memberName)
    {
        var type = obj.GetType();
        var binder = Binder.GetMember(CSharpBinderFlags.None, memberName, type,
            new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) });
        var callsite = CallSite<Func<CallSite, object, object>>.Create(binder);
        try
        {
            return callsite.Target(callsite, obj);
        }
        catch (RuntimeBinderException)
        {
            return null;
        }
    }
#>
