<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="$(SolutionDir)Camille\gen\Chsword.JDynamic.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Dynamic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Chsword" #>
<#@ import namespace="Microsoft.CSharp.RuntimeBinder" #>
<#@ output extension=".cs" #>
<#
    dynamic spec = new JDynamic(File.ReadAllText(Host.ResolvePath(".spec.json")));
    var schemas = spec.components.schemas;
#>
// This file is automatically generated.
// Do not directly edit.
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version <#= spec.info.version #>

using System.Collections.Generic;
using Newtonsoft.Json;

#region data objects
<#
    foreach (string schemaKey in GetKeys(schemas))
    {
        if ("Error".Equals(schemaKey))
        {
            continue;
        }
        var schemaSplit = schemaKey.Split('.');
        var endpoint = schemaSplit[0];
        var schemaName = NormailzeSchemaName(schemaSplit[1]);
        var schema = GetDynamicMember(schemas, schemaKey);
        IDictionary<string, dynamic> props = DynamicToDict(schema.properties);
#>

// <#= endpoint #>
namespace MingweiSamuel.Camille.<#= NormalizeEndpointName(endpoint) #>
{
<#
        string desc = GetDynamicMember(schema, "description");
        if (desc != null)
            WriteLine("    /// " + desc);
#>
    public struct <#= schemaName #>
    {
        public <#= schemaName #>(<#= string.Join(",\r\n                ", props.Select(kv => GetJsonProperty(kv.Key) + ' ' +
            StringifyType(kv.Value) + ' ' + NormalizeArgName(kv.Key))) #>) {
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            if (name.Equals(schemaName))
                name += StringifyType(propKv.Value);
            var argName = NormalizeArgName(propKv.Key);
            var thiz = argName.Equals(name) ? "this." : "";
            WriteLine($"            {thiz}{name} = {argName};");
        }
#>
        }
<#
        foreach (var propKv in props)
        {
            var name = NormalizePropName(propKv.Key, schemaName, propKv.Value);
            var prop = propKv.Value;
#>
        <#= GetJsonProperty(propKv.Key) #>
        public readonly <#= StringifyType(prop) #> <#= name #>;
<#
        }
#>
    }
}
<#
    }
#>
#endregion
<#+
    public static string StringifyType(dynamic prop)
    {
        var anyOf = GetDynamicMember(prop, "anyOf");
        if (anyOf != null)
        {
            prop = anyOf[0];
        }

        string refType = GetDynamicMember(prop, "$ref");
        if (refType != null)
        {
            return NormailzeSchemaName(refType.Substring(refType.IndexOf('.') + 1));
        }
        switch ((string) prop.type)
        {
            case "boolean": return "bool";
            case "integer": return "int32".Equals(prop.format) ? "int" : "long";
            case "number": return prop.format;
            case "array": return StringifyType(prop.items) + "[]";
            case "object":
                return "IDictionary<" + StringifyType(GetDynamicMember(prop, "x-key")) + ", " +
                    StringifyType(prop.additionalProperties) + ">";
            default: return prop.type;
        }
    }

    private static string Capitalize(string input)
    {
        return input.First().ToString().ToUpper() + input.Substring(1);
    }

    private static string Decapitalize(string input)
    {
        return input.First().ToString().ToLower() + input.Substring(1);
    }

    private static string GetJsonProperty(string name)
    {
        return $"[JsonProperty(\"{name}\")]";
    }

    private static string NormalizeArgName(string name)
    {
        var tokens = name.Split('_');
        var argName = Decapitalize(string.Join("", tokens.Select(Capitalize)));
        if ("base".Equals(argName))
            return "Base";
        return argName;
    }

    private static string NormalizePropName(string propName, string schemaName, object value)
    {
        var tokens = propName.Split('_');
        var name = string.Join("", tokens.Select(Capitalize));
        if (name.Equals(schemaName))
            name += StringifyType(value);
        return name;
    }

    private static string NormalizeEndpointName(string name)
    {
        var tokens = name.Split('-');
        return string.Join("", tokens
            .Take(tokens.Length - 1)
            .Select(Capitalize));
    }

    private static string NormailzeSchemaName(string name)
    {
        return Regex.Replace(name, @"DTO", "", RegexOptions.IgnoreCase);
    }

    private static IDictionary<string, dynamic> DynamicToDict(JDynamic obj)
    {
        return GetKeys(obj).ToDictionary(k => k, k => GetDynamicMember(obj, k));
    }

    private static ICollection<string> GetKeys(JDynamic obj)
    {
        return ((IDictionary<string, object>) obj.Value).Keys;
    }

    private static object GetDynamicMember(object obj, string memberName)
    {
        var type = obj.GetType();
        var binder = Binder.GetMember(CSharpBinderFlags.None, memberName, type,
            new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) });
        var callsite = CallSite<Func<CallSite, object, object>>.Create(binder);
        try
        {
            return callsite.Target(callsite, obj);
        }
        catch (RuntimeBinderException)
        {
            return null;
        }
    }
#>
