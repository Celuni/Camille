
// This file is automatically generated.
// Do not directly edit.
// Generated on 2019-10-11T03:00:51.793Z

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version 0c74167e0eaaeb6de1c7e8219fecaabcf8386d1f

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using MingweiSamuel.Camille.Enums;

// ReSharper disable RedundantStringInterpolation
// ReSharper disable InconsistentNaming

#region methods
namespace MingweiSamuel.Camille
{
    public partial class RiotApi
    {
        public readonly ChampionMasteryV4Endpoints ChampionMasteryV4;
        public readonly ChampionV3Endpoints ChampionV3;
        public readonly LeagueExpV4Endpoints LeagueExpV4;
        public readonly LeagueV4Endpoints LeagueV4;
        public readonly LolStatusV3Endpoints LolStatusV3;
        public readonly MatchV4Endpoints MatchV4;
        public readonly SpectatorV4Endpoints SpectatorV4;
        public readonly SummonerV4Endpoints SummonerV4;
        public readonly ThirdPartyCodeV4Endpoints ThirdPartyCodeV4;
        public readonly TournamentStubV4Endpoints TournamentStubV4;
        public readonly TournamentV4Endpoints TournamentV4;

        private RiotApi()
        {
            ChampionMasteryV4 = new ChampionMasteryV4Endpoints(this);
            ChampionV3 = new ChampionV3Endpoints(this);
            LeagueExpV4 = new LeagueExpV4Endpoints(this);
            LeagueV4 = new LeagueV4Endpoints(this);
            LolStatusV3 = new LolStatusV3Endpoints(this);
            MatchV4 = new MatchV4Endpoints(this);
            SpectatorV4 = new SpectatorV4Endpoints(this);
            SummonerV4 = new SummonerV4Endpoints(this);
            ThirdPartyCodeV4 = new ThirdPartyCodeV4Endpoints(this);
            TournamentStubV4 = new TournamentStubV4Endpoints(this);
            TournamentV4 = new TournamentV4Endpoints(this);
        }
    }

    /// <summary>
    /// ChampionMasteryV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4">https://developer.riotgames.com/api-methods/#champion-mastery-v4</a>
    /// </summary>
    public class ChampionMasteryV4Endpoints : Endpoints
    {
        internal ChampionMasteryV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get all champion mastery entries sorted by number of champion points descending,<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public ChampionMasteryV4.ChampionMastery[] GetAllChampionMasteries(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<ChampionMasteryV4.ChampionMastery[]>("champion-mastery-v4.getAllChampionMasteries", $"/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get all champion mastery entries sorted by number of champion points descending,<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<ChampionMasteryV4.ChampionMastery[]> GetAllChampionMasteriesAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<ChampionMasteryV4.ChampionMastery[]>("champion-mastery-v4.getAllChampionMasteries", $"/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a champion mastery by player ID and champion ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="championId">Champion ID to retrieve Champion Mastery for (required)</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public ChampionMasteryV4.ChampionMastery GetChampionMastery(Region region, string encryptedSummonerId, long championId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<ChampionMasteryV4.ChampionMastery>("champion-mastery-v4.getChampionMastery", $"/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a champion mastery by player ID and champion ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="championId">Champion ID to retrieve Champion Mastery for (required)</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<ChampionMasteryV4.ChampionMastery> GetChampionMasteryAsync(Region region, string encryptedSummonerId, long championId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<ChampionMasteryV4.ChampionMastery>("champion-mastery-v4.getChampionMastery", $"/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a player's total champion mastery score, which is the sum of individual champion mastery levels.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public int GetChampionMasteryScore(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<int>("champion-mastery-v4.getChampionMasteryScore", $"/lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a player's total champion mastery score, which is the sum of individual champion mastery levels.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore">https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID associated with the player (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<int> GetChampionMasteryScoreAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<int>("champion-mastery-v4.getChampionMasteryScore", $"/lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// ChampionV3 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#champion-v3">https://developer.riotgames.com/api-methods/#champion-v3</a>
    /// </summary>
    public class ChampionV3Endpoints : Endpoints
    {
        internal ChampionV3Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo">https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public ChampionV3.ChampionInfo GetChampionInfo(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<ChampionV3.ChampionInfo>("champion-v3.getChampionInfo", $"/lol/platform/v3/champion-rotations",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo">https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<ChampionV3.ChampionInfo> GetChampionInfoAsync(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<ChampionV3.ChampionInfo>("champion-v3.getChampionInfo", $"/lol/platform/v3/champion-rotations",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// LeagueExpV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#league-exp-v4">https://developer.riotgames.com/api-methods/#league-exp-v4</a>
    /// </summary>
    public class LeagueExpV4Endpoints : Endpoints
    {
        internal LeagueExpV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get all the league entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries">https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue">Note that the queue value must be a valid ranked queue. (required)</param>
        /// <param name="tier"> (required)</param>
        /// <param name="division"> (required)</param>
        /// <param name="page">Starts with page 1. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueExpV4.LeagueEntry[] GetLeagueEntries(Region region, string division, string tier, string queue, int? page = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueExpV4.LeagueEntry[]>("league-exp-v4.getLeagueEntries", $"/lol/league-exp/v4/entries/{queue}/{tier}/{division}",
                region, MakeParams(nameof(page), page), false, cancellationToken);
        }

        /// <summary>
        /// Get all the league entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries">https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue">Note that the queue value must be a valid ranked queue. (required)</param>
        /// <param name="tier"> (required)</param>
        /// <param name="division"> (required)</param>
        /// <param name="page">Starts with page 1. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueExpV4.LeagueEntry[]> GetLeagueEntriesAsync(Region region, string division, string tier, string queue, int? page = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueExpV4.LeagueEntry[]>("league-exp-v4.getLeagueEntries", $"/lol/league-exp/v4/entries/{queue}/{tier}/{division}",
                region, MakeParams(nameof(page), page), false, cancellationToken);
        }

    }
    /// <summary>
    /// LeagueV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#league-v4">https://developer.riotgames.com/api-methods/#league-v4</a>
    /// </summary>
    public class LeagueV4Endpoints : Endpoints
    {
        internal LeagueV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get the challenger league for given queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueList GetChallengerLeague(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueList>("league-v4.getChallengerLeague", $"/lol/league/v4/challengerleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get the challenger league for given queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueList> GetChallengerLeagueAsync(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueList>("league-v4.getChallengerLeague", $"/lol/league/v4/challengerleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get league entries in all queues for a given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueEntry[] GetLeagueEntriesForSummoner(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueEntry[]>("league-v4.getLeagueEntriesForSummoner", $"/lol/league/v4/entries/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get league entries in all queues for a given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueEntry[]> GetLeagueEntriesForSummonerAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueEntry[]>("league-v4.getLeagueEntriesForSummoner", $"/lol/league/v4/entries/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get all the league entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="division"> (required)</param>
        /// <param name="tier"> (required)</param>
        /// <param name="queue">Note that the queue value must be a valid ranked queue. (required)</param>
        /// <param name="page">Starts with page 1. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueEntry[] GetLeagueEntries(Region region, string queue, string tier, string division, int? page = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueEntry[]>("league-v4.getLeagueEntries", $"/lol/league/v4/entries/{queue}/{tier}/{division}",
                region, MakeParams(nameof(page), page), false, cancellationToken);
        }

        /// <summary>
        /// Get all the league entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="division"> (required)</param>
        /// <param name="tier"> (required)</param>
        /// <param name="queue">Note that the queue value must be a valid ranked queue. (required)</param>
        /// <param name="page">Starts with page 1. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueEntry[]> GetLeagueEntriesAsync(Region region, string queue, string tier, string division, int? page = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueEntry[]>("league-v4.getLeagueEntries", $"/lol/league/v4/entries/{queue}/{tier}/{division}",
                region, MakeParams(nameof(page), page), false, cancellationToken);
        }

        /// <summary>
        /// Get the grandmaster league of a specific queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueList GetGrandmasterLeague(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueList>("league-v4.getGrandmasterLeague", $"/lol/league/v4/grandmasterleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get the grandmaster league of a specific queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueList> GetGrandmasterLeagueAsync(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueList>("league-v4.getGrandmasterLeague", $"/lol/league/v4/grandmasterleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get league with given ID, including inactive entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="leagueId">The UUID of the league. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueList GetLeagueById(Region region, string leagueId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueList>("league-v4.getLeagueById", $"/lol/league/v4/leagues/{leagueId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get league with given ID, including inactive entries.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById">https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="leagueId">The UUID of the league. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueList> GetLeagueByIdAsync(Region region, string leagueId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueList>("league-v4.getLeagueById", $"/lol/league/v4/leagues/{leagueId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get the master league for given queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LeagueV4.LeagueList GetMasterLeague(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LeagueV4.LeagueList>("league-v4.getMasterLeague", $"/lol/league/v4/masterleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get the master league for given queue.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague">https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="queue"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LeagueV4.LeagueList> GetMasterLeagueAsync(Region region, string queue, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LeagueV4.LeagueList>("league-v4.getMasterLeague", $"/lol/league/v4/masterleagues/by-queue/{queue}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// LolStatusV3 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#lol-status-v3">https://developer.riotgames.com/api-methods/#lol-status-v3</a>
    /// </summary>
    public class LolStatusV3Endpoints : Endpoints
    {
        internal LolStatusV3Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get League of Legends status for the given shard.<para />
        /// ## Rate Limit Notes<para />
        /// Requests to this API are not counted against the application Rate Limits.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData">https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public LolStatusV3.ShardStatus GetShardData(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<LolStatusV3.ShardStatus>("lol-status-v3.getShardData", $"/lol/status/v3/shard-data",
                region, MakeParams(), true, cancellationToken);
        }

        /// <summary>
        /// Get League of Legends status for the given shard.<para />
        /// ## Rate Limit Notes<para />
        /// Requests to this API are not counted against the application Rate Limits.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData">https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<LolStatusV3.ShardStatus> GetShardDataAsync(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<LolStatusV3.ShardStatus>("lol-status-v3.getShardData", $"/lol/status/v3/shard-data",
                region, MakeParams(), true, cancellationToken);
        }

    }
    /// <summary>
    /// MatchV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#match-v4">https://developer.riotgames.com/api-methods/#match-v4</a>
    /// </summary>
    public class MatchV4Endpoints : Endpoints
    {
        internal MatchV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get match IDs by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public long[] GetMatchIdsByTournamentCode(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<long[]>("match-v4.getMatchIdsByTournamentCode", $"/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match IDs by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<long[]> GetMatchIdsByTournamentCodeAsync(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<long[]>("match-v4.getMatchIdsByTournamentCode", $"/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match by match ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public MatchV4.Match GetMatch(Region region, long matchId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<MatchV4.Match>("match-v4.getMatch", $"/lol/match/v4/matches/{matchId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match by match ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<MatchV4.Match> GetMatchAsync(Region region, long matchId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<MatchV4.Match>("match-v4.getMatch", $"/lol/match/v4/matches/{matchId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match by match ID and tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code. (required)</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public MatchV4.Match GetMatchByTournamentCode(Region region, long matchId, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<MatchV4.Match>("match-v4.getMatchByTournamentCode", $"/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match by match ID and tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code. (required)</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<MatchV4.Match> GetMatchByTournamentCodeAsync(Region region, long matchId, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<MatchV4.Match>("match-v4.getMatchByTournamentCode", $"/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.<para />
        /// ## Implementation Notes<para />
        /// A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.<para />
        /// <para />
        /// If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.<para />
        /// <para />
        /// If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedAccountId">The account ID. (required)</param>
        /// <param name="champion">Set of champion IDs for filtering the matchlist. (optional)</param>
        /// <param name="queue">Set of queue IDs for filtering the matchlist. (optional)</param>
        /// <param name="season">Set of season IDs for filtering the matchlist. (optional)</param>
        /// <param name="endTime">The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="beginTime">The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="endIndex">The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="beginIndex">The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public MatchV4.Matchlist GetMatchlist(Region region, string encryptedAccountId, int[] champion = null, int[] queue = null, int[] season = null, long? endTime = null, long? beginTime = null, int? endIndex = null, int? beginIndex = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<MatchV4.Matchlist>("match-v4.getMatchlist", $"/lol/match/v4/matchlists/by-account/{encryptedAccountId}",
                region, MakeParams(nameof(champion), champion, nameof(queue), queue, nameof(season), season, nameof(endTime), endTime, nameof(beginTime), beginTime, nameof(endIndex), endIndex, nameof(beginIndex), beginIndex), false, cancellationToken);
        }

        /// <summary>
        /// Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.<para />
        /// ## Implementation Notes<para />
        /// A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.<para />
        /// <para />
        /// If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.<para />
        /// <para />
        /// If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedAccountId">The account ID. (required)</param>
        /// <param name="champion">Set of champion IDs for filtering the matchlist. (optional)</param>
        /// <param name="queue">Set of queue IDs for filtering the matchlist. (optional)</param>
        /// <param name="season">Set of season IDs for filtering the matchlist. (optional)</param>
        /// <param name="endTime">The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="beginTime">The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="endIndex">The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="beginIndex">The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<MatchV4.Matchlist> GetMatchlistAsync(Region region, string encryptedAccountId, int[] champion = null, int[] queue = null, int[] season = null, long? endTime = null, long? beginTime = null, int? endIndex = null, int? beginIndex = null, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<MatchV4.Matchlist>("match-v4.getMatchlist", $"/lol/match/v4/matchlists/by-account/{encryptedAccountId}",
                region, MakeParams(nameof(champion), champion, nameof(queue), queue, nameof(season), season, nameof(endTime), endTime, nameof(beginTime), beginTime, nameof(endIndex), endIndex, nameof(beginIndex), beginIndex), false, cancellationToken);
        }

        /// <summary>
        /// Get match timeline by match ID.<para />
        /// ## Implementation Notes<para />
        /// Not all matches have timeline data.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public MatchV4.MatchTimeline GetMatchTimeline(Region region, long matchId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<MatchV4.MatchTimeline>("match-v4.getMatchTimeline", $"/lol/match/v4/timelines/by-match/{matchId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get match timeline by match ID.<para />
        /// ## Implementation Notes<para />
        /// Not all matches have timeline data.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="matchId">The match ID. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<MatchV4.MatchTimeline> GetMatchTimelineAsync(Region region, long matchId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<MatchV4.MatchTimeline>("match-v4.getMatchTimeline", $"/lol/match/v4/timelines/by-match/{matchId}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// SpectatorV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#spectator-v4">https://developer.riotgames.com/api-methods/#spectator-v4</a>
    /// </summary>
    public class SpectatorV4Endpoints : Endpoints
    {
        internal SpectatorV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get current game information for the given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner">https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">The ID of the summoner. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SpectatorV4.CurrentGameInfo GetCurrentGameInfoBySummoner(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SpectatorV4.CurrentGameInfo>("spectator-v4.getCurrentGameInfoBySummoner", $"/lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get current game information for the given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner">https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">The ID of the summoner. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SpectatorV4.CurrentGameInfo> GetCurrentGameInfoBySummonerAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SpectatorV4.CurrentGameInfo>("spectator-v4.getCurrentGameInfoBySummoner", $"/lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get list of featured games.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames">https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SpectatorV4.FeaturedGames GetFeaturedGames(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SpectatorV4.FeaturedGames>("spectator-v4.getFeaturedGames", $"/lol/spectator/v4/featured-games",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get list of featured games.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames">https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SpectatorV4.FeaturedGames> GetFeaturedGamesAsync(Region region, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SpectatorV4.FeaturedGames>("spectator-v4.getFeaturedGames", $"/lol/spectator/v4/featured-games",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// SummonerV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#summoner-v4">https://developer.riotgames.com/api-methods/#summoner-v4</a>
    /// </summary>
    public class SummonerV4Endpoints : Endpoints
    {
        internal SummonerV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get a summoner by account ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedAccountId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SummonerV4.Summoner GetByAccountId(Region region, string encryptedAccountId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SummonerV4.Summoner>("summoner-v4.getByAccountId", $"/lol/summoner/v4/summoners/by-account/{encryptedAccountId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by account ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedAccountId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SummonerV4.Summoner> GetByAccountIdAsync(Region region, string encryptedAccountId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SummonerV4.Summoner>("summoner-v4.getByAccountId", $"/lol/summoner/v4/summoners/by-account/{encryptedAccountId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by summoner name.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="summonerName">Summoner Name (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SummonerV4.Summoner GetBySummonerName(Region region, string summonerName, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SummonerV4.Summoner>("summoner-v4.getBySummonerName", $"/lol/summoner/v4/summoners/by-name/{summonerName}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by summoner name.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="summonerName">Summoner Name (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SummonerV4.Summoner> GetBySummonerNameAsync(Region region, string summonerName, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SummonerV4.Summoner>("summoner-v4.getBySummonerName", $"/lol/summoner/v4/summoners/by-name/{summonerName}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by PUUID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedPUUID">Summoner ID (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SummonerV4.Summoner GetByPUUID(Region region, string encryptedPUUID, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SummonerV4.Summoner>("summoner-v4.getByPUUID", $"/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by PUUID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedPUUID">Summoner ID (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SummonerV4.Summoner> GetByPUUIDAsync(Region region, string encryptedPUUID, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SummonerV4.Summoner>("summoner-v4.getByPUUID", $"/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public SummonerV4.Summoner GetBySummonerId(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<SummonerV4.Summoner>("summoner-v4.getBySummonerId", $"/lol/summoner/v4/summoners/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get a summoner by summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId">https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId">Summoner ID (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<SummonerV4.Summoner> GetBySummonerIdAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<SummonerV4.Summoner>("summoner-v4.getBySummonerId", $"/lol/summoner/v4/summoners/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// ThirdPartyCodeV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#third-party-code-v4">https://developer.riotgames.com/api-methods/#third-party-code-v4</a>
    /// </summary>
    public class ThirdPartyCodeV4Endpoints : Endpoints
    {
        internal ThirdPartyCodeV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Get third party code for a given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId">https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public string GetThirdPartyCodeBySummonerId(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<string>("third-party-code-v4.getThirdPartyCodeBySummonerId", $"/lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Get third party code for a given summoner ID.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId">https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="encryptedSummonerId"> (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<string> GetThirdPartyCodeBySummonerIdAsync(Region region, string encryptedSummonerId, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<string>("third-party-code-v4.getThirdPartyCodeBySummonerId", $"/lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// TournamentStubV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#tournament-stub-v4">https://developer.riotgames.com/api-methods/#tournament-stub-v4</a>
    /// </summary>
    public class TournamentStubV4Endpoints : Endpoints
    {
        internal TournamentStubV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Gets a mock list of lobby events by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode">https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The short code to look up lobby events for (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public TournamentStubV4.LobbyEventWrapper GetLobbyEventsByCode(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<TournamentStubV4.LobbyEventWrapper>("tournament-stub-v4.getLobbyEventsByCode", $"/lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Gets a mock list of lobby events by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode">https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The short code to look up lobby events for (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<TournamentStubV4.LobbyEventWrapper> GetLobbyEventsByCodeAsync(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<TournamentStubV4.LobbyEventWrapper>("tournament-stub-v4.getLobbyEventsByCode", $"/lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

    }
    /// <summary>
    /// TournamentV4 endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#tournament-v4">https://developer.riotgames.com/api-methods/#tournament-v4</a>
    /// </summary>
    public class TournamentV4Endpoints : Endpoints
    {
        internal TournamentV4Endpoints(RiotApi riotApi) : base(riotApi)
        {}

        /// <summary>
        /// Returns the tournament code DTO associated with a tournament code string.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode">https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code string. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public TournamentV4.TournamentCode GetTournamentCode(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<TournamentV4.TournamentCode>("tournament-v4.getTournamentCode", $"/lol/tournament/v4/codes/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Returns the tournament code DTO associated with a tournament code string.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode">https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The tournament code string. (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<TournamentV4.TournamentCode> GetTournamentCodeAsync(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<TournamentV4.TournamentCode>("tournament-v4.getTournamentCode", $"/lol/tournament/v4/codes/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Gets a list of lobby events by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode">https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The short code to look up lobby events for (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public TournamentV4.LobbyEventWrapper GetLobbyEventsByCode(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get<TournamentV4.LobbyEventWrapper>("tournament-v4.getLobbyEventsByCode", $"/lol/tournament/v4/lobby-events/by-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

        /// <summary>
        /// Gets a list of lobby events by tournament code.<para />
        /// Official API Reference: <a href="https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode">https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
        /// <param name="tournamentCode">The short code to look up lobby events for (required)</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public Task<TournamentV4.LobbyEventWrapper> GetLobbyEventsByCodeAsync(Region region, string tournamentCode, CancellationToken? cancellationToken = null)
        {
            return RiotApi.GetAsync<TournamentV4.LobbyEventWrapper>("tournament-v4.getLobbyEventsByCode", $"/lol/tournament/v4/lobby-events/by-code/{tournamentCode}",
                region, MakeParams(), false, cancellationToken);
        }

    }
}
#endregion

#region data objects
// champion-mastery-v4
namespace MingweiSamuel.Camille.ChampionMasteryV4
{
    /// <summary>
    /// ChampionMastery data object. This class is automatically generated.<para />
    /// This object contains single Champion Mastery information for player and champion combination.
    /// </summary>
    public class ChampionMastery
    {
        public ChampionMastery([JsonProperty("chestGranted")] bool chestGranted,
                [JsonProperty("championLevel")] int championLevel,
                [JsonProperty("championPoints")] int championPoints,
                [JsonProperty("championId")] long championId,
                [JsonProperty("championPointsUntilNextLevel")] long championPointsUntilNextLevel,
                [JsonProperty("lastPlayTime")] long lastPlayTime,
                [JsonProperty("tokensEarned")] int tokensEarned,
                [JsonProperty("championPointsSinceLastLevel")] long championPointsSinceLastLevel,
                [JsonProperty("summonerId")] string summonerId)
        {
            ChestGranted = chestGranted;
            ChampionLevel = championLevel;
            ChampionPoints = championPoints;
            ChampionId = championId;
            ChampionPointsUntilNextLevel = championPointsUntilNextLevel;
            LastPlayTime = lastPlayTime;
            TokensEarned = tokensEarned;
            ChampionPointsSinceLastLevel = championPointsSinceLastLevel;
            SummonerId = summonerId;
        }
        /// <summary>
        /// Is chest granted for this champion or not in current season.
        /// </summary>
        [JsonProperty("chestGranted")]
        public readonly bool ChestGranted;
        /// <summary>
        /// Champion level for specified player and champion combination.
        /// </summary>
        [JsonProperty("championLevel")]
        public readonly int ChampionLevel;
        /// <summary>
        /// Total number of champion points for this player and champion combination - they are used to determine championLevel.
        /// </summary>
        [JsonProperty("championPoints")]
        public readonly int ChampionPoints;
        /// <summary>
        /// Champion ID for this entry.
        /// </summary>
        [JsonProperty("championId")]
        public readonly long ChampionId;
        /// <summary>
        /// Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion.
        /// </summary>
        [JsonProperty("championPointsUntilNextLevel")]
        public readonly long ChampionPointsUntilNextLevel;
        /// <summary>
        /// Last time this champion was played by this player - in Unix milliseconds time format.
        /// </summary>
        [JsonProperty("lastPlayTime")]
        public readonly long LastPlayTime;
        /// <summary>
        /// The token earned for this champion to levelup.
        /// </summary>
        [JsonProperty("tokensEarned")]
        public readonly int TokensEarned;
        /// <summary>
        /// Number of points earned since current level has been achieved.
        /// </summary>
        [JsonProperty("championPointsSinceLastLevel")]
        public readonly long ChampionPointsSinceLastLevel;
        /// <summary>
        /// Summoner ID for this entry. (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ChampionMastery"
                + "ChestGranted: " + ChestGranted + ", "
                + "ChampionLevel: " + ChampionLevel + ", "
                + "ChampionPoints: " + ChampionPoints + ", "
                + "ChampionId: " + ChampionId + ", "
                + "ChampionPointsUntilNextLevel: " + ChampionPointsUntilNextLevel + ", "
                + "LastPlayTime: " + LastPlayTime + ", "
                + "TokensEarned: " + TokensEarned + ", "
                + "ChampionPointsSinceLastLevel: " + ChampionPointsSinceLastLevel + ", "
                + "SummonerId: " + SummonerId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// champion-v3
namespace MingweiSamuel.Camille.ChampionV3
{
    /// <summary>
    /// ChampionInfo data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ChampionInfo
    {
        public ChampionInfo([JsonProperty("freeChampionIdsForNewPlayers")] int[] freeChampionIdsForNewPlayers,
                [JsonProperty("freeChampionIds")] int[] freeChampionIds,
                [JsonProperty("maxNewPlayerLevel")] int maxNewPlayerLevel)
        {
            FreeChampionIdsForNewPlayers = freeChampionIdsForNewPlayers;
            FreeChampionIds = freeChampionIds;
            MaxNewPlayerLevel = maxNewPlayerLevel;
        }
        [JsonProperty("freeChampionIdsForNewPlayers")]
        public readonly int[] FreeChampionIdsForNewPlayers;
        [JsonProperty("freeChampionIds")]
        public readonly int[] FreeChampionIds;
        [JsonProperty("maxNewPlayerLevel")]
        public readonly int MaxNewPlayerLevel;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ChampionInfo"
                + "FreeChampionIdsForNewPlayers: " + FreeChampionIdsForNewPlayers + ", "
                + "FreeChampionIds: " + FreeChampionIds + ", "
                + "MaxNewPlayerLevel: " + MaxNewPlayerLevel + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-exp-v4
namespace MingweiSamuel.Camille.LeagueExpV4
{
    /// <summary>
    /// LeagueEntry data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LeagueEntry
    {
        public LeagueEntry([JsonProperty("queueType")] string queueType,
                [JsonProperty("summonerName")] string summonerName,
                [JsonProperty("hotStreak")] bool hotStreak,
                [JsonProperty("miniSeries")] MiniSeries miniSeries,
                [JsonProperty("wins")] int wins,
                [JsonProperty("veteran")] bool veteran,
                [JsonProperty("losses")] int losses,
                [JsonProperty("rank")] string rank,
                [JsonProperty("leagueId")] string leagueId,
                [JsonProperty("inactive")] bool inactive,
                [JsonProperty("freshBlood")] bool freshBlood,
                [JsonProperty("tier")] string tier,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("leaguePoints")] int leaguePoints)
        {
            QueueType = queueType;
            SummonerName = summonerName;
            HotStreak = hotStreak;
            MiniSeries = miniSeries;
            Wins = wins;
            Veteran = veteran;
            Losses = losses;
            Rank = rank;
            LeagueId = leagueId;
            Inactive = inactive;
            FreshBlood = freshBlood;
            Tier = tier;
            SummonerId = summonerId;
            LeaguePoints = leaguePoints;
        }
        [JsonProperty("queueType")]
        public readonly string QueueType;
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        [JsonProperty("hotStreak")]
        public readonly bool HotStreak;
        [JsonProperty("miniSeries")]
        public readonly MiniSeries MiniSeries;
        /// <summary>
        /// Winning team on Summoners Rift. First placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("wins")]
        public readonly int Wins;
        [JsonProperty("veteran")]
        public readonly bool Veteran;
        /// <summary>
        /// Losing team on Summoners Rift. Second through eighth placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("losses")]
        public readonly int Losses;
        [JsonProperty("rank")]
        public readonly string Rank;
        [JsonProperty("leagueId")]
        public readonly string LeagueId;
        [JsonProperty("inactive")]
        public readonly bool Inactive;
        [JsonProperty("freshBlood")]
        public readonly bool FreshBlood;
        [JsonProperty("tier")]
        public readonly string Tier;
        /// <summary>
        /// Player's summonerId (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        [JsonProperty("leaguePoints")]
        public readonly int LeaguePoints;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LeagueEntry"
                + "QueueType: " + QueueType + ", "
                + "SummonerName: " + SummonerName + ", "
                + "HotStreak: " + HotStreak + ", "
                + "MiniSeries: " + MiniSeries + ", "
                + "Wins: " + Wins + ", "
                + "Veteran: " + Veteran + ", "
                + "Losses: " + Losses + ", "
                + "Rank: " + Rank + ", "
                + "LeagueId: " + LeagueId + ", "
                + "Inactive: " + Inactive + ", "
                + "FreshBlood: " + FreshBlood + ", "
                + "Tier: " + Tier + ", "
                + "SummonerId: " + SummonerId + ", "
                + "LeaguePoints: " + LeaguePoints + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-exp-v4
namespace MingweiSamuel.Camille.LeagueExpV4
{
    /// <summary>
    /// MiniSeries data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MiniSeries
    {
        public MiniSeries([JsonProperty("progress")] string progress,
                [JsonProperty("losses")] int losses,
                [JsonProperty("target")] int target,
                [JsonProperty("wins")] int wins)
        {
            Progress = progress;
            Losses = losses;
            Target = target;
            Wins = wins;
        }
        [JsonProperty("progress")]
        public readonly string Progress;
        [JsonProperty("losses")]
        public readonly int Losses;
        [JsonProperty("target")]
        public readonly int Target;
        [JsonProperty("wins")]
        public readonly int Wins;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MiniSeries"
                + "Progress: " + Progress + ", "
                + "Losses: " + Losses + ", "
                + "Target: " + Target + ", "
                + "Wins: " + Wins + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-v4
namespace MingweiSamuel.Camille.LeagueV4
{
    /// <summary>
    /// LeagueList data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LeagueList
    {
        public LeagueList([JsonProperty("leagueId")] string leagueId,
                [JsonProperty("tier")] string tier,
                [JsonProperty("entries")] LeagueItem[] entries,
                [JsonProperty("queue")] string queue,
                [JsonProperty("name")] string name)
        {
            LeagueId = leagueId;
            Tier = tier;
            Entries = entries;
            Queue = queue;
            Name = name;
        }
        [JsonProperty("leagueId")]
        public readonly string LeagueId;
        [JsonProperty("tier")]
        public readonly string Tier;
        [JsonProperty("entries")]
        public readonly LeagueItem[] Entries;
        [JsonProperty("queue")]
        public readonly string Queue;
        [JsonProperty("name")]
        public readonly string Name;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LeagueList"
                + "LeagueId: " + LeagueId + ", "
                + "Tier: " + Tier + ", "
                + "Entries: " + Entries + ", "
                + "Queue: " + Queue + ", "
                + "Name: " + Name + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-v4
namespace MingweiSamuel.Camille.LeagueV4
{
    /// <summary>
    /// LeagueItem data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LeagueItem
    {
        public LeagueItem([JsonProperty("summonerName")] string summonerName,
                [JsonProperty("hotStreak")] bool hotStreak,
                [JsonProperty("miniSeries")] MiniSeries miniSeries,
                [JsonProperty("wins")] int wins,
                [JsonProperty("veteran")] bool veteran,
                [JsonProperty("losses")] int losses,
                [JsonProperty("freshBlood")] bool freshBlood,
                [JsonProperty("inactive")] bool inactive,
                [JsonProperty("rank")] string rank,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("leaguePoints")] int leaguePoints)
        {
            SummonerName = summonerName;
            HotStreak = hotStreak;
            MiniSeries = miniSeries;
            Wins = wins;
            Veteran = veteran;
            Losses = losses;
            FreshBlood = freshBlood;
            Inactive = inactive;
            Rank = rank;
            SummonerId = summonerId;
            LeaguePoints = leaguePoints;
        }
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        [JsonProperty("hotStreak")]
        public readonly bool HotStreak;
        [JsonProperty("miniSeries")]
        public readonly MiniSeries MiniSeries;
        /// <summary>
        /// Winning team on Summoners Rift. First placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("wins")]
        public readonly int Wins;
        [JsonProperty("veteran")]
        public readonly bool Veteran;
        /// <summary>
        /// Losing team on Summoners Rift. Second through eighth placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("losses")]
        public readonly int Losses;
        [JsonProperty("freshBlood")]
        public readonly bool FreshBlood;
        [JsonProperty("inactive")]
        public readonly bool Inactive;
        [JsonProperty("rank")]
        public readonly string Rank;
        /// <summary>
        /// Player's summonerId (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        [JsonProperty("leaguePoints")]
        public readonly int LeaguePoints;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LeagueItem"
                + "SummonerName: " + SummonerName + ", "
                + "HotStreak: " + HotStreak + ", "
                + "MiniSeries: " + MiniSeries + ", "
                + "Wins: " + Wins + ", "
                + "Veteran: " + Veteran + ", "
                + "Losses: " + Losses + ", "
                + "FreshBlood: " + FreshBlood + ", "
                + "Inactive: " + Inactive + ", "
                + "Rank: " + Rank + ", "
                + "SummonerId: " + SummonerId + ", "
                + "LeaguePoints: " + LeaguePoints + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-v4
namespace MingweiSamuel.Camille.LeagueV4
{
    /// <summary>
    /// MiniSeries data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MiniSeries
    {
        public MiniSeries([JsonProperty("progress")] string progress,
                [JsonProperty("losses")] int losses,
                [JsonProperty("target")] int target,
                [JsonProperty("wins")] int wins)
        {
            Progress = progress;
            Losses = losses;
            Target = target;
            Wins = wins;
        }
        [JsonProperty("progress")]
        public readonly string Progress;
        [JsonProperty("losses")]
        public readonly int Losses;
        [JsonProperty("target")]
        public readonly int Target;
        [JsonProperty("wins")]
        public readonly int Wins;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MiniSeries"
                + "Progress: " + Progress + ", "
                + "Losses: " + Losses + ", "
                + "Target: " + Target + ", "
                + "Wins: " + Wins + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// league-v4
namespace MingweiSamuel.Camille.LeagueV4
{
    /// <summary>
    /// LeagueEntry data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LeagueEntry
    {
        public LeagueEntry([JsonProperty("queueType")] string queueType,
                [JsonProperty("summonerName")] string summonerName,
                [JsonProperty("hotStreak")] bool hotStreak,
                [JsonProperty("miniSeries")] MiniSeries miniSeries,
                [JsonProperty("wins")] int wins,
                [JsonProperty("veteran")] bool veteran,
                [JsonProperty("losses")] int losses,
                [JsonProperty("rank")] string rank,
                [JsonProperty("leagueId")] string leagueId,
                [JsonProperty("inactive")] bool inactive,
                [JsonProperty("freshBlood")] bool freshBlood,
                [JsonProperty("tier")] string tier,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("leaguePoints")] int leaguePoints)
        {
            QueueType = queueType;
            SummonerName = summonerName;
            HotStreak = hotStreak;
            MiniSeries = miniSeries;
            Wins = wins;
            Veteran = veteran;
            Losses = losses;
            Rank = rank;
            LeagueId = leagueId;
            Inactive = inactive;
            FreshBlood = freshBlood;
            Tier = tier;
            SummonerId = summonerId;
            LeaguePoints = leaguePoints;
        }
        [JsonProperty("queueType")]
        public readonly string QueueType;
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        [JsonProperty("hotStreak")]
        public readonly bool HotStreak;
        [JsonProperty("miniSeries")]
        public readonly MiniSeries MiniSeries;
        /// <summary>
        /// Winning team on Summoners Rift. First placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("wins")]
        public readonly int Wins;
        [JsonProperty("veteran")]
        public readonly bool Veteran;
        /// <summary>
        /// Losing team on Summoners Rift. Second through eighth placement in Teamfight Tactics.
        /// </summary>
        [JsonProperty("losses")]
        public readonly int Losses;
        [JsonProperty("rank")]
        public readonly string Rank;
        [JsonProperty("leagueId")]
        public readonly string LeagueId;
        [JsonProperty("inactive")]
        public readonly bool Inactive;
        [JsonProperty("freshBlood")]
        public readonly bool FreshBlood;
        [JsonProperty("tier")]
        public readonly string Tier;
        /// <summary>
        /// Player's summonerId (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        [JsonProperty("leaguePoints")]
        public readonly int LeaguePoints;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LeagueEntry"
                + "QueueType: " + QueueType + ", "
                + "SummonerName: " + SummonerName + ", "
                + "HotStreak: " + HotStreak + ", "
                + "MiniSeries: " + MiniSeries + ", "
                + "Wins: " + Wins + ", "
                + "Veteran: " + Veteran + ", "
                + "Losses: " + Losses + ", "
                + "Rank: " + Rank + ", "
                + "LeagueId: " + LeagueId + ", "
                + "Inactive: " + Inactive + ", "
                + "FreshBlood: " + FreshBlood + ", "
                + "Tier: " + Tier + ", "
                + "SummonerId: " + SummonerId + ", "
                + "LeaguePoints: " + LeaguePoints + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// lol-status-v3
namespace MingweiSamuel.Camille.LolStatusV3
{
    /// <summary>
    /// ShardStatus data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ShardStatus
    {
        public ShardStatus([JsonProperty("name")] string name,
                [JsonProperty("region_tag")] string regionTag,
                [JsonProperty("hostname")] string hostname,
                [JsonProperty("services")] Service[] services,
                [JsonProperty("slug")] string slug,
                [JsonProperty("locales")] string[] locales)
        {
            Name = name;
            RegionTag = regionTag;
            Hostname = hostname;
            Services = services;
            Slug = slug;
            Locales = locales;
        }
        [JsonProperty("name")]
        public readonly string Name;
        [JsonProperty("region_tag")]
        public readonly string RegionTag;
        [JsonProperty("hostname")]
        public readonly string Hostname;
        [JsonProperty("services")]
        public readonly Service[] Services;
        [JsonProperty("slug")]
        public readonly string Slug;
        [JsonProperty("locales")]
        public readonly string[] Locales;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ShardStatus"
                + "Name: " + Name + ", "
                + "RegionTag: " + RegionTag + ", "
                + "Hostname: " + Hostname + ", "
                + "Services: " + Services + ", "
                + "Slug: " + Slug + ", "
                + "Locales: " + Locales + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// lol-status-v3
namespace MingweiSamuel.Camille.LolStatusV3
{
    /// <summary>
    /// Service data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Service
    {
        public Service([JsonProperty("status")] string status,
                [JsonProperty("incidents")] Incident[] incidents,
                [JsonProperty("name")] string name,
                [JsonProperty("slug")] string slug)
        {
            Status = status;
            Incidents = incidents;
            Name = name;
            Slug = slug;
        }
        [JsonProperty("status")]
        public readonly string Status;
        [JsonProperty("incidents")]
        public readonly Incident[] Incidents;
        [JsonProperty("name")]
        public readonly string Name;
        [JsonProperty("slug")]
        public readonly string Slug;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Service"
                + "Status: " + Status + ", "
                + "Incidents: " + Incidents + ", "
                + "Name: " + Name + ", "
                + "Slug: " + Slug + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// lol-status-v3
namespace MingweiSamuel.Camille.LolStatusV3
{
    /// <summary>
    /// Incident data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Incident
    {
        public Incident([JsonProperty("active")] bool active,
                [JsonProperty("created_at")] string createdAt,
                [JsonProperty("id")] long id,
                [JsonProperty("updates")] Message[] updates)
        {
            Active = active;
            CreatedAt = createdAt;
            Id = id;
            Updates = updates;
        }
        [JsonProperty("active")]
        public readonly bool Active;
        [JsonProperty("created_at")]
        public readonly string CreatedAt;
        [JsonProperty("id")]
        public readonly long Id;
        [JsonProperty("updates")]
        public readonly Message[] Updates;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Incident"
                + "Active: " + Active + ", "
                + "CreatedAt: " + CreatedAt + ", "
                + "Id: " + Id + ", "
                + "Updates: " + Updates + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// lol-status-v3
namespace MingweiSamuel.Camille.LolStatusV3
{
    /// <summary>
    /// Message data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Message
    {
        public Message([JsonProperty("severity")] string severity,
                [JsonProperty("author")] string author,
                [JsonProperty("created_at")] string createdAt,
                [JsonProperty("translations")] Translation[] translations,
                [JsonProperty("updated_at")] string updatedAt,
                [JsonProperty("content")] string content,
                [JsonProperty("id")] string id)
        {
            Severity = severity;
            Author = author;
            CreatedAt = createdAt;
            Translations = translations;
            UpdatedAt = updatedAt;
            Content = content;
            Id = id;
        }
        [JsonProperty("severity")]
        public readonly string Severity;
        [JsonProperty("author")]
        public readonly string Author;
        [JsonProperty("created_at")]
        public readonly string CreatedAt;
        [JsonProperty("translations")]
        public readonly Translation[] Translations;
        [JsonProperty("updated_at")]
        public readonly string UpdatedAt;
        [JsonProperty("content")]
        public readonly string Content;
        [JsonProperty("id")]
        public readonly string Id;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Message"
                + "Severity: " + Severity + ", "
                + "Author: " + Author + ", "
                + "CreatedAt: " + CreatedAt + ", "
                + "Translations: " + Translations + ", "
                + "UpdatedAt: " + UpdatedAt + ", "
                + "Content: " + Content + ", "
                + "Id: " + Id + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// lol-status-v3
namespace MingweiSamuel.Camille.LolStatusV3
{
    /// <summary>
    /// Translation data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Translation
    {
        public Translation([JsonProperty("locale")] string locale,
                [JsonProperty("content")] string content,
                [JsonProperty("heading")] string heading)
        {
            Locale = locale;
            Content = content;
            Heading = heading;
        }
        [JsonProperty("locale")]
        public readonly string Locale;
        [JsonProperty("content")]
        public readonly string Content;
        [JsonProperty("heading")]
        public readonly string Heading;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Translation"
                + "Locale: " + Locale + ", "
                + "Content: " + Content + ", "
                + "Heading: " + Heading + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Match data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Match
    {
        public Match([JsonProperty("seasonId")] int seasonId,
                [JsonProperty("queueId")] int queueId,
                [JsonProperty("gameId")] long gameId,
                [JsonProperty("participantIdentities")] ParticipantIdentity[] participantIdentities,
                [JsonProperty("gameVersion")] string gameVersion,
                [JsonProperty("platformId")] string platformId,
                [JsonProperty("gameMode")] string gameMode,
                [JsonProperty("mapId")] int mapId,
                [JsonProperty("gameType")] string gameType,
                [JsonProperty("teams")] TeamStats[] teams,
                [JsonProperty("participants")] Participant[] participants,
                [JsonProperty("gameDuration")] long gameDuration,
                [JsonProperty("gameCreation")] long gameCreation)
        {
            SeasonId = seasonId;
            QueueId = queueId;
            GameId = gameId;
            ParticipantIdentities = participantIdentities;
            GameVersion = gameVersion;
            PlatformId = platformId;
            GameMode = gameMode;
            MapId = mapId;
            GameType = gameType;
            Teams = teams;
            Participants = participants;
            GameDuration = gameDuration;
            GameCreation = gameCreation;
        }
        /// <summary>
        /// Please refer to the Game Constants documentation.
        /// </summary>
        [JsonProperty("seasonId")]
        public readonly int SeasonId;
        /// <summary>
        /// Please refer to the Game Constants documentation.
        /// </summary>
        [JsonProperty("queueId")]
        public readonly int QueueId;
        [JsonProperty("gameId")]
        public readonly long GameId;
        /// <summary>
        /// Participant identity information.
        /// </summary>
        [JsonProperty("participantIdentities")]
        public readonly ParticipantIdentity[] ParticipantIdentities;
        /// <summary>
        /// The major.minor version typically indicates the patch the match was played on.
        /// </summary>
        [JsonProperty("gameVersion")]
        public readonly string GameVersion;
        /// <summary>
        /// Platform where the match was played.
        /// </summary>
        [JsonProperty("platformId")]
        public readonly string PlatformId;
        /// <summary>
        /// Please refer to the Game Constants documentation.
        /// </summary>
        [JsonProperty("gameMode")]
        public readonly string GameMode;
        /// <summary>
        /// Please refer to the Game Constants documentation.
        /// </summary>
        [JsonProperty("mapId")]
        public readonly int MapId;
        /// <summary>
        /// Please refer to the Game Constants documentation.
        /// </summary>
        [JsonProperty("gameType")]
        public readonly string GameType;
        /// <summary>
        /// Team information.
        /// </summary>
        [JsonProperty("teams")]
        public readonly TeamStats[] Teams;
        /// <summary>
        /// Participant information.
        /// </summary>
        [JsonProperty("participants")]
        public readonly Participant[] Participants;
        /// <summary>
        /// Match duration in seconds.
        /// </summary>
        [JsonProperty("gameDuration")]
        public readonly long GameDuration;
        /// <summary>
        /// Designates the timestamp when champion select ended and the loading screen appeared, NOT when the game timer was at 0:00.
        /// </summary>
        [JsonProperty("gameCreation")]
        public readonly long GameCreation;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Match"
                + "SeasonId: " + SeasonId + ", "
                + "QueueId: " + QueueId + ", "
                + "GameId: " + GameId + ", "
                + "ParticipantIdentities: " + ParticipantIdentities + ", "
                + "GameVersion: " + GameVersion + ", "
                + "PlatformId: " + PlatformId + ", "
                + "GameMode: " + GameMode + ", "
                + "MapId: " + MapId + ", "
                + "GameType: " + GameType + ", "
                + "Teams: " + Teams + ", "
                + "Participants: " + Participants + ", "
                + "GameDuration: " + GameDuration + ", "
                + "GameCreation: " + GameCreation + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// ParticipantIdentity data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ParticipantIdentity
    {
        public ParticipantIdentity([JsonProperty("player")] Player player,
                [JsonProperty("participantId")] int participantId)
        {
            Player = player;
            ParticipantId = participantId;
        }
        /// <summary>
        /// Player information.
        /// </summary>
        [JsonProperty("player")]
        public readonly Player Player;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ParticipantIdentity"
                + "Player: " + Player + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Player data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Player
    {
        public Player([JsonProperty("currentPlatformId")] string currentPlatformId,
                [JsonProperty("summonerName")] string summonerName,
                [JsonProperty("matchHistoryUri")] string matchHistoryUri,
                [JsonProperty("platformId")] string platformId,
                [JsonProperty("currentAccountId")] string currentAccountId,
                [JsonProperty("profileIcon")] int profileIcon,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("accountId")] string accountId)
        {
            CurrentPlatformId = currentPlatformId;
            SummonerName = summonerName;
            MatchHistoryUri = matchHistoryUri;
            PlatformId = platformId;
            CurrentAccountId = currentAccountId;
            ProfileIcon = profileIcon;
            SummonerId = summonerId;
            AccountId = accountId;
        }
        [JsonProperty("currentPlatformId")]
        public readonly string CurrentPlatformId;
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        [JsonProperty("matchHistoryUri")]
        public readonly string MatchHistoryUri;
        /// <summary>
        /// Original platformId.
        /// </summary>
        [JsonProperty("platformId")]
        public readonly string PlatformId;
        /// <summary>
        /// Player's current accountId (Encrypted)
        /// </summary>
        [JsonProperty("currentAccountId")]
        public readonly string CurrentAccountId;
        [JsonProperty("profileIcon")]
        public readonly int ProfileIcon;
        /// <summary>
        /// Player's summonerId (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        /// <summary>
        /// Player's original accountId (Encrypted)
        /// </summary>
        [JsonProperty("accountId")]
        public readonly string AccountId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Player"
                + "CurrentPlatformId: " + CurrentPlatformId + ", "
                + "SummonerName: " + SummonerName + ", "
                + "MatchHistoryUri: " + MatchHistoryUri + ", "
                + "PlatformId: " + PlatformId + ", "
                + "CurrentAccountId: " + CurrentAccountId + ", "
                + "ProfileIcon: " + ProfileIcon + ", "
                + "SummonerId: " + SummonerId + ", "
                + "AccountId: " + AccountId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// TeamStats data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TeamStats
    {
        public TeamStats([JsonProperty("firstDragon")] bool firstDragon,
                [JsonProperty("firstInhibitor")] bool firstInhibitor,
                [JsonProperty("bans")] TeamBans[] bans,
                [JsonProperty("baronKills")] int baronKills,
                [JsonProperty("firstRiftHerald")] bool firstRiftHerald,
                [JsonProperty("firstBaron")] bool firstBaron,
                [JsonProperty("riftHeraldKills")] int riftHeraldKills,
                [JsonProperty("firstBlood")] bool firstBlood,
                [JsonProperty("teamId")] int teamId,
                [JsonProperty("firstTower")] bool firstTower,
                [JsonProperty("vilemawKills")] int vilemawKills,
                [JsonProperty("inhibitorKills")] int inhibitorKills,
                [JsonProperty("towerKills")] int towerKills,
                [JsonProperty("dominionVictoryScore")] int dominionVictoryScore,
                [JsonProperty("win")] string win,
                [JsonProperty("dragonKills")] int dragonKills)
        {
            FirstDragon = firstDragon;
            FirstInhibitor = firstInhibitor;
            Bans = bans;
            BaronKills = baronKills;
            FirstRiftHerald = firstRiftHerald;
            FirstBaron = firstBaron;
            RiftHeraldKills = riftHeraldKills;
            FirstBlood = firstBlood;
            TeamId = teamId;
            FirstTower = firstTower;
            VilemawKills = vilemawKills;
            InhibitorKills = inhibitorKills;
            TowerKills = towerKills;
            DominionVictoryScore = dominionVictoryScore;
            Win = win;
            DragonKills = dragonKills;
        }
        /// <summary>
        /// Flag indicating whether or not the team scored the first Dragon kill.
        /// </summary>
        [JsonProperty("firstDragon")]
        public readonly bool FirstDragon;
        /// <summary>
        /// Flag indicating whether or not the team destroyed the first inhibitor.
        /// </summary>
        [JsonProperty("firstInhibitor")]
        public readonly bool FirstInhibitor;
        /// <summary>
        /// If match queueId has a draft, contains banned champion data, otherwise empty.
        /// </summary>
        [JsonProperty("bans")]
        public readonly TeamBans[] Bans;
        /// <summary>
        /// Number of times the team killed Baron.
        /// </summary>
        [JsonProperty("baronKills")]
        public readonly int BaronKills;
        /// <summary>
        /// Flag indicating whether or not the team scored the first Rift Herald kill.
        /// </summary>
        [JsonProperty("firstRiftHerald")]
        public readonly bool FirstRiftHerald;
        /// <summary>
        /// Flag indicating whether or not the team scored the first Baron kill.
        /// </summary>
        [JsonProperty("firstBaron")]
        public readonly bool FirstBaron;
        /// <summary>
        /// Number of times the team killed Rift Herald.
        /// </summary>
        [JsonProperty("riftHeraldKills")]
        public readonly int RiftHeraldKills;
        /// <summary>
        /// Flag indicating whether or not the team scored the first blood.
        /// </summary>
        [JsonProperty("firstBlood")]
        public readonly bool FirstBlood;
        /// <summary>
        /// 100 for blue side. 200 for red side.
        /// </summary>
        [JsonProperty("teamId")]
        public readonly int TeamId;
        /// <summary>
        /// Flag indicating whether or not the team destroyed the first tower.
        /// </summary>
        [JsonProperty("firstTower")]
        public readonly bool FirstTower;
        /// <summary>
        /// Number of times the team killed Vilemaw.
        /// </summary>
        [JsonProperty("vilemawKills")]
        public readonly int VilemawKills;
        /// <summary>
        /// Number of inhibitors the team destroyed.
        /// </summary>
        [JsonProperty("inhibitorKills")]
        public readonly int InhibitorKills;
        /// <summary>
        /// Number of towers the team destroyed.
        /// </summary>
        [JsonProperty("towerKills")]
        public readonly int TowerKills;
        /// <summary>
        /// For Dominion matches, specifies the points the team had at game end.
        /// </summary>
        [JsonProperty("dominionVictoryScore")]
        public readonly int DominionVictoryScore;
        /// <summary>
        /// String indicating whether or not the team won. There are only two values visibile in public match history.<para />
        /// (Legal values:  Fail,  Win)
        /// </summary>
        [JsonProperty("win")]
        public readonly string Win;
        /// <summary>
        /// Number of times the team killed Dragon.
        /// </summary>
        [JsonProperty("dragonKills")]
        public readonly int DragonKills;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TeamStats"
                + "FirstDragon: " + FirstDragon + ", "
                + "FirstInhibitor: " + FirstInhibitor + ", "
                + "Bans: " + Bans + ", "
                + "BaronKills: " + BaronKills + ", "
                + "FirstRiftHerald: " + FirstRiftHerald + ", "
                + "FirstBaron: " + FirstBaron + ", "
                + "RiftHeraldKills: " + RiftHeraldKills + ", "
                + "FirstBlood: " + FirstBlood + ", "
                + "TeamId: " + TeamId + ", "
                + "FirstTower: " + FirstTower + ", "
                + "VilemawKills: " + VilemawKills + ", "
                + "InhibitorKills: " + InhibitorKills + ", "
                + "TowerKills: " + TowerKills + ", "
                + "DominionVictoryScore: " + DominionVictoryScore + ", "
                + "Win: " + Win + ", "
                + "DragonKills: " + DragonKills + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// TeamBans data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TeamBans
    {
        public TeamBans([JsonProperty("pickTurn")] int pickTurn,
                [JsonProperty("championId")] int championId)
        {
            PickTurn = pickTurn;
            ChampionId = championId;
        }
        /// <summary>
        /// Turn during which the champion was banned.
        /// </summary>
        [JsonProperty("pickTurn")]
        public readonly int PickTurn;
        /// <summary>
        /// Banned championId.
        /// </summary>
        [JsonProperty("championId")]
        public readonly int ChampionId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TeamBans"
                + "PickTurn: " + PickTurn + ", "
                + "ChampionId: " + ChampionId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Participant data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Participant
    {
        public Participant([JsonProperty("stats")] ParticipantStats stats,
                [JsonProperty("participantId")] int participantId,
                [JsonProperty("runes")] Rune[] runes,
                [JsonProperty("timeline")] ParticipantTimeline timeline,
                [JsonProperty("teamId")] int teamId,
                [JsonProperty("spell2Id")] int spell2Id,
                [JsonProperty("masteries")] Mastery[] masteries,
                [JsonProperty("highestAchievedSeasonTier")] string highestAchievedSeasonTier,
                [JsonProperty("spell1Id")] int spell1Id,
                [JsonProperty("championId")] int championId)
        {
            Stats = stats;
            ParticipantId = participantId;
            Runes = runes;
            Timeline = timeline;
            TeamId = teamId;
            Spell2Id = spell2Id;
            Masteries = masteries;
            HighestAchievedSeasonTier = highestAchievedSeasonTier;
            Spell1Id = spell1Id;
            ChampionId = championId;
        }
        /// <summary>
        /// Participant statistics.
        /// </summary>
        [JsonProperty("stats")]
        public readonly ParticipantStats Stats;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;
        /// <summary>
        /// List of legacy Rune information. Not included for matches played with Runes Reforged.
        /// </summary>
        [JsonProperty("runes")]
        public readonly Rune[] Runes;
        /// <summary>
        /// Participant timeline data.
        /// </summary>
        [JsonProperty("timeline")]
        public readonly ParticipantTimeline Timeline;
        /// <summary>
        /// 100 for blue side. 200 for red side.
        /// </summary>
        [JsonProperty("teamId")]
        public readonly int TeamId;
        /// <summary>
        /// Second Summoner Spell id.
        /// </summary>
        [JsonProperty("spell2Id")]
        public readonly int Spell2Id;
        /// <summary>
        /// List of legacy Mastery information. Not included for matches played with Runes Reforged.
        /// </summary>
        [JsonProperty("masteries")]
        public readonly Mastery[] Masteries;
        /// <summary>
        /// Highest ranked tier achieved for the previous season in a specific subset of queueIds, if any, otherwise null. Used to display border in game loading screen. Please refer to the Ranked Info documentation.<para />
        /// (Legal values:  CHALLENGER,  MASTER,  DIAMOND,  PLATINUM,  GOLD,  SILVER,  BRONZE,  UNRANKED)
        /// </summary>
        [JsonProperty("highestAchievedSeasonTier")]
        public readonly string HighestAchievedSeasonTier;
        /// <summary>
        /// First Summoner Spell id.
        /// </summary>
        [JsonProperty("spell1Id")]
        public readonly int Spell1Id;
        [JsonProperty("championId")]
        public readonly int ChampionId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Participant"
                + "Stats: " + Stats + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "Runes: " + Runes + ", "
                + "Timeline: " + Timeline + ", "
                + "TeamId: " + TeamId + ", "
                + "Spell2Id: " + Spell2Id + ", "
                + "Masteries: " + Masteries + ", "
                + "HighestAchievedSeasonTier: " + HighestAchievedSeasonTier + ", "
                + "Spell1Id: " + Spell1Id + ", "
                + "ChampionId: " + ChampionId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// ParticipantStats data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ParticipantStats
    {
        public ParticipantStats([JsonProperty("firstBloodAssist")] bool firstBloodAssist,
                [JsonProperty("visionScore")] long visionScore,
                [JsonProperty("magicDamageDealtToChampions")] long magicDamageDealtToChampions,
                [JsonProperty("damageDealtToObjectives")] long damageDealtToObjectives,
                [JsonProperty("totalTimeCrowdControlDealt")] int totalTimeCrowdControlDealt,
                [JsonProperty("longestTimeSpentLiving")] int longestTimeSpentLiving,
                [JsonProperty("perk1Var1")] int perk1Var1,
                [JsonProperty("perk1Var3")] int perk1Var3,
                [JsonProperty("perk1Var2")] int perk1Var2,
                [JsonProperty("tripleKills")] int tripleKills,
                [JsonProperty("perk3Var3")] int perk3Var3,
                [JsonProperty("nodeNeutralizeAssist")] int nodeNeutralizeAssist,
                [JsonProperty("perk3Var2")] int perk3Var2,
                [JsonProperty("playerScore9")] int playerScore9,
                [JsonProperty("playerScore8")] int playerScore8,
                [JsonProperty("kills")] int kills,
                [JsonProperty("playerScore1")] int playerScore1,
                [JsonProperty("playerScore0")] int playerScore0,
                [JsonProperty("playerScore3")] int playerScore3,
                [JsonProperty("playerScore2")] int playerScore2,
                [JsonProperty("playerScore5")] int playerScore5,
                [JsonProperty("playerScore4")] int playerScore4,
                [JsonProperty("playerScore7")] int playerScore7,
                [JsonProperty("playerScore6")] int playerScore6,
                [JsonProperty("perk5Var1")] int perk5Var1,
                [JsonProperty("perk5Var3")] int perk5Var3,
                [JsonProperty("perk5Var2")] int perk5Var2,
                [JsonProperty("totalScoreRank")] int totalScoreRank,
                [JsonProperty("neutralMinionsKilled")] int neutralMinionsKilled,
                [JsonProperty("damageDealtToTurrets")] long damageDealtToTurrets,
                [JsonProperty("physicalDamageDealtToChampions")] long physicalDamageDealtToChampions,
                [JsonProperty("nodeCapture")] int nodeCapture,
                [JsonProperty("largestMultiKill")] int largestMultiKill,
                [JsonProperty("perk2Var2")] int perk2Var2,
                [JsonProperty("perk2Var3")] int perk2Var3,
                [JsonProperty("totalUnitsHealed")] int totalUnitsHealed,
                [JsonProperty("perk2Var1")] int perk2Var1,
                [JsonProperty("perk4Var1")] int perk4Var1,
                [JsonProperty("perk4Var2")] int perk4Var2,
                [JsonProperty("perk4Var3")] int perk4Var3,
                [JsonProperty("wardsKilled")] int wardsKilled,
                [JsonProperty("largestCriticalStrike")] int largestCriticalStrike,
                [JsonProperty("largestKillingSpree")] int largestKillingSpree,
                [JsonProperty("quadraKills")] int quadraKills,
                [JsonProperty("teamObjective")] int teamObjective,
                [JsonProperty("magicDamageDealt")] long magicDamageDealt,
                [JsonProperty("item2")] int item2,
                [JsonProperty("item3")] int item3,
                [JsonProperty("item0")] int item0,
                [JsonProperty("neutralMinionsKilledTeamJungle")] int neutralMinionsKilledTeamJungle,
                [JsonProperty("item6")] int item6,
                [JsonProperty("item4")] int item4,
                [JsonProperty("item5")] int item5,
                [JsonProperty("perk1")] int perk1,
                [JsonProperty("perk0")] int perk0,
                [JsonProperty("perk3")] int perk3,
                [JsonProperty("perk2")] int perk2,
                [JsonProperty("perk5")] int perk5,
                [JsonProperty("perk4")] int perk4,
                [JsonProperty("perk3Var1")] int perk3Var1,
                [JsonProperty("damageSelfMitigated")] long damageSelfMitigated,
                [JsonProperty("magicalDamageTaken")] long magicalDamageTaken,
                [JsonProperty("firstInhibitorKill")] bool firstInhibitorKill,
                [JsonProperty("trueDamageTaken")] long trueDamageTaken,
                [JsonProperty("nodeNeutralize")] int nodeNeutralize,
                [JsonProperty("assists")] int assists,
                [JsonProperty("combatPlayerScore")] int combatPlayerScore,
                [JsonProperty("perkPrimaryStyle")] int perkPrimaryStyle,
                [JsonProperty("goldSpent")] int goldSpent,
                [JsonProperty("trueDamageDealt")] long trueDamageDealt,
                [JsonProperty("participantId")] int participantId,
                [JsonProperty("totalDamageTaken")] long totalDamageTaken,
                [JsonProperty("physicalDamageDealt")] long physicalDamageDealt,
                [JsonProperty("sightWardsBoughtInGame")] int sightWardsBoughtInGame,
                [JsonProperty("totalDamageDealtToChampions")] long totalDamageDealtToChampions,
                [JsonProperty("physicalDamageTaken")] long physicalDamageTaken,
                [JsonProperty("totalPlayerScore")] int totalPlayerScore,
                [JsonProperty("win")] bool win,
                [JsonProperty("objectivePlayerScore")] int objectivePlayerScore,
                [JsonProperty("totalDamageDealt")] long totalDamageDealt,
                [JsonProperty("item1")] int item1,
                [JsonProperty("neutralMinionsKilledEnemyJungle")] int neutralMinionsKilledEnemyJungle,
                [JsonProperty("deaths")] int deaths,
                [JsonProperty("wardsPlaced")] int wardsPlaced,
                [JsonProperty("perkSubStyle")] int perkSubStyle,
                [JsonProperty("turretKills")] int turretKills,
                [JsonProperty("firstBloodKill")] bool firstBloodKill,
                [JsonProperty("trueDamageDealtToChampions")] long trueDamageDealtToChampions,
                [JsonProperty("goldEarned")] int goldEarned,
                [JsonProperty("killingSprees")] int killingSprees,
                [JsonProperty("unrealKills")] int unrealKills,
                [JsonProperty("altarsCaptured")] int altarsCaptured,
                [JsonProperty("firstTowerAssist")] bool firstTowerAssist,
                [JsonProperty("firstTowerKill")] bool firstTowerKill,
                [JsonProperty("champLevel")] int champLevel,
                [JsonProperty("doubleKills")] int doubleKills,
                [JsonProperty("nodeCaptureAssist")] int nodeCaptureAssist,
                [JsonProperty("inhibitorKills")] int inhibitorKills,
                [JsonProperty("firstInhibitorAssist")] bool firstInhibitorAssist,
                [JsonProperty("perk0Var1")] int perk0Var1,
                [JsonProperty("perk0Var2")] int perk0Var2,
                [JsonProperty("perk0Var3")] int perk0Var3,
                [JsonProperty("visionWardsBoughtInGame")] int visionWardsBoughtInGame,
                [JsonProperty("altarsNeutralized")] int altarsNeutralized,
                [JsonProperty("pentaKills")] int pentaKills,
                [JsonProperty("totalHeal")] long totalHeal,
                [JsonProperty("totalMinionsKilled")] int totalMinionsKilled,
                [JsonProperty("timeCCingOthers")] long timeCCingOthers)
        {
            FirstBloodAssist = firstBloodAssist;
            VisionScore = visionScore;
            MagicDamageDealtToChampions = magicDamageDealtToChampions;
            DamageDealtToObjectives = damageDealtToObjectives;
            TotalTimeCrowdControlDealt = totalTimeCrowdControlDealt;
            LongestTimeSpentLiving = longestTimeSpentLiving;
            Perk1Var1 = perk1Var1;
            Perk1Var3 = perk1Var3;
            Perk1Var2 = perk1Var2;
            TripleKills = tripleKills;
            Perk3Var3 = perk3Var3;
            NodeNeutralizeAssist = nodeNeutralizeAssist;
            Perk3Var2 = perk3Var2;
            PlayerScore9 = playerScore9;
            PlayerScore8 = playerScore8;
            Kills = kills;
            PlayerScore1 = playerScore1;
            PlayerScore0 = playerScore0;
            PlayerScore3 = playerScore3;
            PlayerScore2 = playerScore2;
            PlayerScore5 = playerScore5;
            PlayerScore4 = playerScore4;
            PlayerScore7 = playerScore7;
            PlayerScore6 = playerScore6;
            Perk5Var1 = perk5Var1;
            Perk5Var3 = perk5Var3;
            Perk5Var2 = perk5Var2;
            TotalScoreRank = totalScoreRank;
            NeutralMinionsKilled = neutralMinionsKilled;
            DamageDealtToTurrets = damageDealtToTurrets;
            PhysicalDamageDealtToChampions = physicalDamageDealtToChampions;
            NodeCapture = nodeCapture;
            LargestMultiKill = largestMultiKill;
            Perk2Var2 = perk2Var2;
            Perk2Var3 = perk2Var3;
            TotalUnitsHealed = totalUnitsHealed;
            Perk2Var1 = perk2Var1;
            Perk4Var1 = perk4Var1;
            Perk4Var2 = perk4Var2;
            Perk4Var3 = perk4Var3;
            WardsKilled = wardsKilled;
            LargestCriticalStrike = largestCriticalStrike;
            LargestKillingSpree = largestKillingSpree;
            QuadraKills = quadraKills;
            TeamObjective = teamObjective;
            MagicDamageDealt = magicDamageDealt;
            Item2 = item2;
            Item3 = item3;
            Item0 = item0;
            NeutralMinionsKilledTeamJungle = neutralMinionsKilledTeamJungle;
            Item6 = item6;
            Item4 = item4;
            Item5 = item5;
            Perk1 = perk1;
            Perk0 = perk0;
            Perk3 = perk3;
            Perk2 = perk2;
            Perk5 = perk5;
            Perk4 = perk4;
            Perk3Var1 = perk3Var1;
            DamageSelfMitigated = damageSelfMitigated;
            MagicalDamageTaken = magicalDamageTaken;
            FirstInhibitorKill = firstInhibitorKill;
            TrueDamageTaken = trueDamageTaken;
            NodeNeutralize = nodeNeutralize;
            Assists = assists;
            CombatPlayerScore = combatPlayerScore;
            PerkPrimaryStyle = perkPrimaryStyle;
            GoldSpent = goldSpent;
            TrueDamageDealt = trueDamageDealt;
            ParticipantId = participantId;
            TotalDamageTaken = totalDamageTaken;
            PhysicalDamageDealt = physicalDamageDealt;
            SightWardsBoughtInGame = sightWardsBoughtInGame;
            TotalDamageDealtToChampions = totalDamageDealtToChampions;
            PhysicalDamageTaken = physicalDamageTaken;
            TotalPlayerScore = totalPlayerScore;
            Win = win;
            ObjectivePlayerScore = objectivePlayerScore;
            TotalDamageDealt = totalDamageDealt;
            Item1 = item1;
            NeutralMinionsKilledEnemyJungle = neutralMinionsKilledEnemyJungle;
            Deaths = deaths;
            WardsPlaced = wardsPlaced;
            PerkSubStyle = perkSubStyle;
            TurretKills = turretKills;
            FirstBloodKill = firstBloodKill;
            TrueDamageDealtToChampions = trueDamageDealtToChampions;
            GoldEarned = goldEarned;
            KillingSprees = killingSprees;
            UnrealKills = unrealKills;
            AltarsCaptured = altarsCaptured;
            FirstTowerAssist = firstTowerAssist;
            FirstTowerKill = firstTowerKill;
            ChampLevel = champLevel;
            DoubleKills = doubleKills;
            NodeCaptureAssist = nodeCaptureAssist;
            InhibitorKills = inhibitorKills;
            FirstInhibitorAssist = firstInhibitorAssist;
            Perk0Var1 = perk0Var1;
            Perk0Var2 = perk0Var2;
            Perk0Var3 = perk0Var3;
            VisionWardsBoughtInGame = visionWardsBoughtInGame;
            AltarsNeutralized = altarsNeutralized;
            PentaKills = pentaKills;
            TotalHeal = totalHeal;
            TotalMinionsKilled = totalMinionsKilled;
            TimeCCingOthers = timeCCingOthers;
        }
        [JsonProperty("firstBloodAssist")]
        public readonly bool FirstBloodAssist;
        [JsonProperty("visionScore")]
        public readonly long VisionScore;
        [JsonProperty("magicDamageDealtToChampions")]
        public readonly long MagicDamageDealtToChampions;
        [JsonProperty("damageDealtToObjectives")]
        public readonly long DamageDealtToObjectives;
        [JsonProperty("totalTimeCrowdControlDealt")]
        public readonly int TotalTimeCrowdControlDealt;
        [JsonProperty("longestTimeSpentLiving")]
        public readonly int LongestTimeSpentLiving;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk1Var1")]
        public readonly int Perk1Var1;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk1Var3")]
        public readonly int Perk1Var3;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk1Var2")]
        public readonly int Perk1Var2;
        [JsonProperty("tripleKills")]
        public readonly int TripleKills;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk3Var3")]
        public readonly int Perk3Var3;
        [JsonProperty("nodeNeutralizeAssist")]
        public readonly int NodeNeutralizeAssist;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk3Var2")]
        public readonly int Perk3Var2;
        [JsonProperty("playerScore9")]
        public readonly int PlayerScore9;
        [JsonProperty("playerScore8")]
        public readonly int PlayerScore8;
        [JsonProperty("kills")]
        public readonly int Kills;
        [JsonProperty("playerScore1")]
        public readonly int PlayerScore1;
        [JsonProperty("playerScore0")]
        public readonly int PlayerScore0;
        [JsonProperty("playerScore3")]
        public readonly int PlayerScore3;
        [JsonProperty("playerScore2")]
        public readonly int PlayerScore2;
        [JsonProperty("playerScore5")]
        public readonly int PlayerScore5;
        [JsonProperty("playerScore4")]
        public readonly int PlayerScore4;
        [JsonProperty("playerScore7")]
        public readonly int PlayerScore7;
        [JsonProperty("playerScore6")]
        public readonly int PlayerScore6;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk5Var1")]
        public readonly int Perk5Var1;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk5Var3")]
        public readonly int Perk5Var3;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk5Var2")]
        public readonly int Perk5Var2;
        [JsonProperty("totalScoreRank")]
        public readonly int TotalScoreRank;
        [JsonProperty("neutralMinionsKilled")]
        public readonly int NeutralMinionsKilled;
        [JsonProperty("damageDealtToTurrets")]
        public readonly long DamageDealtToTurrets;
        [JsonProperty("physicalDamageDealtToChampions")]
        public readonly long PhysicalDamageDealtToChampions;
        [JsonProperty("nodeCapture")]
        public readonly int NodeCapture;
        [JsonProperty("largestMultiKill")]
        public readonly int LargestMultiKill;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk2Var2")]
        public readonly int Perk2Var2;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk2Var3")]
        public readonly int Perk2Var3;
        [JsonProperty("totalUnitsHealed")]
        public readonly int TotalUnitsHealed;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk2Var1")]
        public readonly int Perk2Var1;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk4Var1")]
        public readonly int Perk4Var1;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk4Var2")]
        public readonly int Perk4Var2;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk4Var3")]
        public readonly int Perk4Var3;
        [JsonProperty("wardsKilled")]
        public readonly int WardsKilled;
        [JsonProperty("largestCriticalStrike")]
        public readonly int LargestCriticalStrike;
        [JsonProperty("largestKillingSpree")]
        public readonly int LargestKillingSpree;
        [JsonProperty("quadraKills")]
        public readonly int QuadraKills;
        [JsonProperty("teamObjective")]
        public readonly int TeamObjective;
        [JsonProperty("magicDamageDealt")]
        public readonly long MagicDamageDealt;
        [JsonProperty("item2")]
        public readonly int Item2;
        [JsonProperty("item3")]
        public readonly int Item3;
        [JsonProperty("item0")]
        public readonly int Item0;
        [JsonProperty("neutralMinionsKilledTeamJungle")]
        public readonly int NeutralMinionsKilledTeamJungle;
        [JsonProperty("item6")]
        public readonly int Item6;
        [JsonProperty("item4")]
        public readonly int Item4;
        [JsonProperty("item5")]
        public readonly int Item5;
        /// <summary>
        /// Primary path rune.
        /// </summary>
        [JsonProperty("perk1")]
        public readonly int Perk1;
        /// <summary>
        /// Primary path keystone rune.
        /// </summary>
        [JsonProperty("perk0")]
        public readonly int Perk0;
        /// <summary>
        /// Primary path rune.
        /// </summary>
        [JsonProperty("perk3")]
        public readonly int Perk3;
        /// <summary>
        /// Primary path rune.
        /// </summary>
        [JsonProperty("perk2")]
        public readonly int Perk2;
        /// <summary>
        /// Secondary path rune.
        /// </summary>
        [JsonProperty("perk5")]
        public readonly int Perk5;
        /// <summary>
        /// Secondary path rune.
        /// </summary>
        [JsonProperty("perk4")]
        public readonly int Perk4;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk3Var1")]
        public readonly int Perk3Var1;
        [JsonProperty("damageSelfMitigated")]
        public readonly long DamageSelfMitigated;
        [JsonProperty("magicalDamageTaken")]
        public readonly long MagicalDamageTaken;
        [JsonProperty("firstInhibitorKill")]
        public readonly bool FirstInhibitorKill;
        [JsonProperty("trueDamageTaken")]
        public readonly long TrueDamageTaken;
        [JsonProperty("nodeNeutralize")]
        public readonly int NodeNeutralize;
        [JsonProperty("assists")]
        public readonly int Assists;
        [JsonProperty("combatPlayerScore")]
        public readonly int CombatPlayerScore;
        /// <summary>
        /// Primary rune path
        /// </summary>
        [JsonProperty("perkPrimaryStyle")]
        public readonly int PerkPrimaryStyle;
        [JsonProperty("goldSpent")]
        public readonly int GoldSpent;
        [JsonProperty("trueDamageDealt")]
        public readonly long TrueDamageDealt;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;
        [JsonProperty("totalDamageTaken")]
        public readonly long TotalDamageTaken;
        [JsonProperty("physicalDamageDealt")]
        public readonly long PhysicalDamageDealt;
        [JsonProperty("sightWardsBoughtInGame")]
        public readonly int SightWardsBoughtInGame;
        [JsonProperty("totalDamageDealtToChampions")]
        public readonly long TotalDamageDealtToChampions;
        [JsonProperty("physicalDamageTaken")]
        public readonly long PhysicalDamageTaken;
        [JsonProperty("totalPlayerScore")]
        public readonly int TotalPlayerScore;
        [JsonProperty("win")]
        public readonly bool Win;
        [JsonProperty("objectivePlayerScore")]
        public readonly int ObjectivePlayerScore;
        [JsonProperty("totalDamageDealt")]
        public readonly long TotalDamageDealt;
        [JsonProperty("item1")]
        public readonly int Item1;
        [JsonProperty("neutralMinionsKilledEnemyJungle")]
        public readonly int NeutralMinionsKilledEnemyJungle;
        [JsonProperty("deaths")]
        public readonly int Deaths;
        [JsonProperty("wardsPlaced")]
        public readonly int WardsPlaced;
        /// <summary>
        /// Secondary rune path
        /// </summary>
        [JsonProperty("perkSubStyle")]
        public readonly int PerkSubStyle;
        [JsonProperty("turretKills")]
        public readonly int TurretKills;
        [JsonProperty("firstBloodKill")]
        public readonly bool FirstBloodKill;
        [JsonProperty("trueDamageDealtToChampions")]
        public readonly long TrueDamageDealtToChampions;
        [JsonProperty("goldEarned")]
        public readonly int GoldEarned;
        [JsonProperty("killingSprees")]
        public readonly int KillingSprees;
        [JsonProperty("unrealKills")]
        public readonly int UnrealKills;
        [JsonProperty("altarsCaptured")]
        public readonly int AltarsCaptured;
        [JsonProperty("firstTowerAssist")]
        public readonly bool FirstTowerAssist;
        [JsonProperty("firstTowerKill")]
        public readonly bool FirstTowerKill;
        [JsonProperty("champLevel")]
        public readonly int ChampLevel;
        [JsonProperty("doubleKills")]
        public readonly int DoubleKills;
        [JsonProperty("nodeCaptureAssist")]
        public readonly int NodeCaptureAssist;
        [JsonProperty("inhibitorKills")]
        public readonly int InhibitorKills;
        [JsonProperty("firstInhibitorAssist")]
        public readonly bool FirstInhibitorAssist;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk0Var1")]
        public readonly int Perk0Var1;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk0Var2")]
        public readonly int Perk0Var2;
        /// <summary>
        /// Post game rune stats.
        /// </summary>
        [JsonProperty("perk0Var3")]
        public readonly int Perk0Var3;
        [JsonProperty("visionWardsBoughtInGame")]
        public readonly int VisionWardsBoughtInGame;
        [JsonProperty("altarsNeutralized")]
        public readonly int AltarsNeutralized;
        [JsonProperty("pentaKills")]
        public readonly int PentaKills;
        [JsonProperty("totalHeal")]
        public readonly long TotalHeal;
        [JsonProperty("totalMinionsKilled")]
        public readonly int TotalMinionsKilled;
        [JsonProperty("timeCCingOthers")]
        public readonly long TimeCCingOthers;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ParticipantStats"
                + "FirstBloodAssist: " + FirstBloodAssist + ", "
                + "VisionScore: " + VisionScore + ", "
                + "MagicDamageDealtToChampions: " + MagicDamageDealtToChampions + ", "
                + "DamageDealtToObjectives: " + DamageDealtToObjectives + ", "
                + "TotalTimeCrowdControlDealt: " + TotalTimeCrowdControlDealt + ", "
                + "LongestTimeSpentLiving: " + LongestTimeSpentLiving + ", "
                + "Perk1Var1: " + Perk1Var1 + ", "
                + "Perk1Var3: " + Perk1Var3 + ", "
                + "Perk1Var2: " + Perk1Var2 + ", "
                + "TripleKills: " + TripleKills + ", "
                + "Perk3Var3: " + Perk3Var3 + ", "
                + "NodeNeutralizeAssist: " + NodeNeutralizeAssist + ", "
                + "Perk3Var2: " + Perk3Var2 + ", "
                + "PlayerScore9: " + PlayerScore9 + ", "
                + "PlayerScore8: " + PlayerScore8 + ", "
                + "Kills: " + Kills + ", "
                + "PlayerScore1: " + PlayerScore1 + ", "
                + "PlayerScore0: " + PlayerScore0 + ", "
                + "PlayerScore3: " + PlayerScore3 + ", "
                + "PlayerScore2: " + PlayerScore2 + ", "
                + "PlayerScore5: " + PlayerScore5 + ", "
                + "PlayerScore4: " + PlayerScore4 + ", "
                + "PlayerScore7: " + PlayerScore7 + ", "
                + "PlayerScore6: " + PlayerScore6 + ", "
                + "Perk5Var1: " + Perk5Var1 + ", "
                + "Perk5Var3: " + Perk5Var3 + ", "
                + "Perk5Var2: " + Perk5Var2 + ", "
                + "TotalScoreRank: " + TotalScoreRank + ", "
                + "NeutralMinionsKilled: " + NeutralMinionsKilled + ", "
                + "DamageDealtToTurrets: " + DamageDealtToTurrets + ", "
                + "PhysicalDamageDealtToChampions: " + PhysicalDamageDealtToChampions + ", "
                + "NodeCapture: " + NodeCapture + ", "
                + "LargestMultiKill: " + LargestMultiKill + ", "
                + "Perk2Var2: " + Perk2Var2 + ", "
                + "Perk2Var3: " + Perk2Var3 + ", "
                + "TotalUnitsHealed: " + TotalUnitsHealed + ", "
                + "Perk2Var1: " + Perk2Var1 + ", "
                + "Perk4Var1: " + Perk4Var1 + ", "
                + "Perk4Var2: " + Perk4Var2 + ", "
                + "Perk4Var3: " + Perk4Var3 + ", "
                + "WardsKilled: " + WardsKilled + ", "
                + "LargestCriticalStrike: " + LargestCriticalStrike + ", "
                + "LargestKillingSpree: " + LargestKillingSpree + ", "
                + "QuadraKills: " + QuadraKills + ", "
                + "TeamObjective: " + TeamObjective + ", "
                + "MagicDamageDealt: " + MagicDamageDealt + ", "
                + "Item2: " + Item2 + ", "
                + "Item3: " + Item3 + ", "
                + "Item0: " + Item0 + ", "
                + "NeutralMinionsKilledTeamJungle: " + NeutralMinionsKilledTeamJungle + ", "
                + "Item6: " + Item6 + ", "
                + "Item4: " + Item4 + ", "
                + "Item5: " + Item5 + ", "
                + "Perk1: " + Perk1 + ", "
                + "Perk0: " + Perk0 + ", "
                + "Perk3: " + Perk3 + ", "
                + "Perk2: " + Perk2 + ", "
                + "Perk5: " + Perk5 + ", "
                + "Perk4: " + Perk4 + ", "
                + "Perk3Var1: " + Perk3Var1 + ", "
                + "DamageSelfMitigated: " + DamageSelfMitigated + ", "
                + "MagicalDamageTaken: " + MagicalDamageTaken + ", "
                + "FirstInhibitorKill: " + FirstInhibitorKill + ", "
                + "TrueDamageTaken: " + TrueDamageTaken + ", "
                + "NodeNeutralize: " + NodeNeutralize + ", "
                + "Assists: " + Assists + ", "
                + "CombatPlayerScore: " + CombatPlayerScore + ", "
                + "PerkPrimaryStyle: " + PerkPrimaryStyle + ", "
                + "GoldSpent: " + GoldSpent + ", "
                + "TrueDamageDealt: " + TrueDamageDealt + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "TotalDamageTaken: " + TotalDamageTaken + ", "
                + "PhysicalDamageDealt: " + PhysicalDamageDealt + ", "
                + "SightWardsBoughtInGame: " + SightWardsBoughtInGame + ", "
                + "TotalDamageDealtToChampions: " + TotalDamageDealtToChampions + ", "
                + "PhysicalDamageTaken: " + PhysicalDamageTaken + ", "
                + "TotalPlayerScore: " + TotalPlayerScore + ", "
                + "Win: " + Win + ", "
                + "ObjectivePlayerScore: " + ObjectivePlayerScore + ", "
                + "TotalDamageDealt: " + TotalDamageDealt + ", "
                + "Item1: " + Item1 + ", "
                + "NeutralMinionsKilledEnemyJungle: " + NeutralMinionsKilledEnemyJungle + ", "
                + "Deaths: " + Deaths + ", "
                + "WardsPlaced: " + WardsPlaced + ", "
                + "PerkSubStyle: " + PerkSubStyle + ", "
                + "TurretKills: " + TurretKills + ", "
                + "FirstBloodKill: " + FirstBloodKill + ", "
                + "TrueDamageDealtToChampions: " + TrueDamageDealtToChampions + ", "
                + "GoldEarned: " + GoldEarned + ", "
                + "KillingSprees: " + KillingSprees + ", "
                + "UnrealKills: " + UnrealKills + ", "
                + "AltarsCaptured: " + AltarsCaptured + ", "
                + "FirstTowerAssist: " + FirstTowerAssist + ", "
                + "FirstTowerKill: " + FirstTowerKill + ", "
                + "ChampLevel: " + ChampLevel + ", "
                + "DoubleKills: " + DoubleKills + ", "
                + "NodeCaptureAssist: " + NodeCaptureAssist + ", "
                + "InhibitorKills: " + InhibitorKills + ", "
                + "FirstInhibitorAssist: " + FirstInhibitorAssist + ", "
                + "Perk0Var1: " + Perk0Var1 + ", "
                + "Perk0Var2: " + Perk0Var2 + ", "
                + "Perk0Var3: " + Perk0Var3 + ", "
                + "VisionWardsBoughtInGame: " + VisionWardsBoughtInGame + ", "
                + "AltarsNeutralized: " + AltarsNeutralized + ", "
                + "PentaKills: " + PentaKills + ", "
                + "TotalHeal: " + TotalHeal + ", "
                + "TotalMinionsKilled: " + TotalMinionsKilled + ", "
                + "TimeCCingOthers: " + TimeCCingOthers + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Rune data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Rune
    {
        public Rune([JsonProperty("runeId")] int runeId,
                [JsonProperty("rank")] int rank)
        {
            RuneId = runeId;
            Rank = rank;
        }
        [JsonProperty("runeId")]
        public readonly int RuneId;
        [JsonProperty("rank")]
        public readonly int Rank;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Rune"
                + "RuneId: " + RuneId + ", "
                + "Rank: " + Rank + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// ParticipantTimeline data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ParticipantTimeline
    {
        public ParticipantTimeline([JsonProperty("lane")] string lane,
                [JsonProperty("participantId")] int participantId,
                [JsonProperty("csDiffPerMinDeltas")] IDictionary<string, double> csDiffPerMinDeltas,
                [JsonProperty("goldPerMinDeltas")] IDictionary<string, double> goldPerMinDeltas,
                [JsonProperty("xpDiffPerMinDeltas")] IDictionary<string, double> xpDiffPerMinDeltas,
                [JsonProperty("creepsPerMinDeltas")] IDictionary<string, double> creepsPerMinDeltas,
                [JsonProperty("xpPerMinDeltas")] IDictionary<string, double> xpPerMinDeltas,
                [JsonProperty("role")] string role,
                [JsonProperty("damageTakenDiffPerMinDeltas")] IDictionary<string, double> damageTakenDiffPerMinDeltas,
                [JsonProperty("damageTakenPerMinDeltas")] IDictionary<string, double> damageTakenPerMinDeltas)
        {
            Lane = lane;
            ParticipantId = participantId;
            CsDiffPerMinDeltas = csDiffPerMinDeltas;
            GoldPerMinDeltas = goldPerMinDeltas;
            XpDiffPerMinDeltas = xpDiffPerMinDeltas;
            CreepsPerMinDeltas = creepsPerMinDeltas;
            XpPerMinDeltas = xpPerMinDeltas;
            Role = role;
            DamageTakenDiffPerMinDeltas = damageTakenDiffPerMinDeltas;
            DamageTakenPerMinDeltas = damageTakenPerMinDeltas;
        }
        /// <summary>
        /// Participant's calculated lane. MID and BOT are legacy values.<para />
        /// (Legal values:  MID,  MIDDLE,  TOP,  JUNGLE,  BOT,  BOTTOM)
        /// </summary>
        [JsonProperty("lane")]
        public readonly string Lane;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;
        /// <summary>
        /// Creep score difference versus the calculated lane opponent(s) for a specified period.
        /// </summary>
        [JsonProperty("csDiffPerMinDeltas")]
        public readonly IDictionary<string, double> CsDiffPerMinDeltas;
        /// <summary>
        /// Gold for a specified period.
        /// </summary>
        [JsonProperty("goldPerMinDeltas")]
        public readonly IDictionary<string, double> GoldPerMinDeltas;
        /// <summary>
        /// Experience difference versus the calculated lane opponent(s) for a specified period.
        /// </summary>
        [JsonProperty("xpDiffPerMinDeltas")]
        public readonly IDictionary<string, double> XpDiffPerMinDeltas;
        /// <summary>
        /// Creeps for a specified period.
        /// </summary>
        [JsonProperty("creepsPerMinDeltas")]
        public readonly IDictionary<string, double> CreepsPerMinDeltas;
        /// <summary>
        /// Experience change for a specified period.
        /// </summary>
        [JsonProperty("xpPerMinDeltas")]
        public readonly IDictionary<string, double> XpPerMinDeltas;
        /// <summary>
        /// Participant's calculated role.<para />
        /// (Legal values:  DUO,  NONE,  SOLO,  DUO_CARRY,  DUO_SUPPORT)
        /// </summary>
        [JsonProperty("role")]
        public readonly string Role;
        /// <summary>
        /// Damage taken difference versus the calculated lane opponent(s) for a specified period.
        /// </summary>
        [JsonProperty("damageTakenDiffPerMinDeltas")]
        public readonly IDictionary<string, double> DamageTakenDiffPerMinDeltas;
        /// <summary>
        /// Damage taken for a specified period.
        /// </summary>
        [JsonProperty("damageTakenPerMinDeltas")]
        public readonly IDictionary<string, double> DamageTakenPerMinDeltas;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ParticipantTimeline"
                + "Lane: " + Lane + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "CsDiffPerMinDeltas: " + CsDiffPerMinDeltas + ", "
                + "GoldPerMinDeltas: " + GoldPerMinDeltas + ", "
                + "XpDiffPerMinDeltas: " + XpDiffPerMinDeltas + ", "
                + "CreepsPerMinDeltas: " + CreepsPerMinDeltas + ", "
                + "XpPerMinDeltas: " + XpPerMinDeltas + ", "
                + "Role: " + Role + ", "
                + "DamageTakenDiffPerMinDeltas: " + DamageTakenDiffPerMinDeltas + ", "
                + "DamageTakenPerMinDeltas: " + DamageTakenPerMinDeltas + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Mastery data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Mastery
    {
        public Mastery([JsonProperty("masteryId")] int masteryId,
                [JsonProperty("rank")] int rank)
        {
            MasteryId = masteryId;
            Rank = rank;
        }
        [JsonProperty("masteryId")]
        public readonly int MasteryId;
        [JsonProperty("rank")]
        public readonly int Rank;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Mastery"
                + "MasteryId: " + MasteryId + ", "
                + "Rank: " + Rank + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// Matchlist data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Matchlist
    {
        public Matchlist([JsonProperty("matches")] MatchReference[] matches,
                [JsonProperty("totalGames")] int totalGames,
                [JsonProperty("startIndex")] int startIndex,
                [JsonProperty("endIndex")] int endIndex)
        {
            Matches = matches;
            TotalGames = totalGames;
            StartIndex = startIndex;
            EndIndex = endIndex;
        }
        [JsonProperty("matches")]
        public readonly MatchReference[] Matches;
        [JsonProperty("totalGames")]
        public readonly int TotalGames;
        [JsonProperty("startIndex")]
        public readonly int StartIndex;
        [JsonProperty("endIndex")]
        public readonly int EndIndex;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Matchlist"
                + "Matches: " + Matches + ", "
                + "TotalGames: " + TotalGames + ", "
                + "StartIndex: " + StartIndex + ", "
                + "EndIndex: " + EndIndex + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchReference data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchReference
    {
        public MatchReference([JsonProperty("lane")] string lane,
                [JsonProperty("gameId")] long gameId,
                [JsonProperty("champion")] int champion,
                [JsonProperty("platformId")] string platformId,
                [JsonProperty("season")] int season,
                [JsonProperty("queue")] int queue,
                [JsonProperty("role")] string role,
                [JsonProperty("timestamp")] long timestamp)
        {
            Lane = lane;
            GameId = gameId;
            Champion = champion;
            PlatformId = platformId;
            Season = season;
            Queue = queue;
            Role = role;
            Timestamp = timestamp;
        }
        [JsonProperty("lane")]
        public readonly string Lane;
        [JsonProperty("gameId")]
        public readonly long GameId;
        [JsonProperty("champion")]
        public readonly int Champion;
        [JsonProperty("platformId")]
        public readonly string PlatformId;
        [JsonProperty("season")]
        public readonly int Season;
        [JsonProperty("queue")]
        public readonly int Queue;
        [JsonProperty("role")]
        public readonly string Role;
        [JsonProperty("timestamp")]
        public readonly long Timestamp;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchReference"
                + "Lane: " + Lane + ", "
                + "GameId: " + GameId + ", "
                + "Champion: " + Champion + ", "
                + "PlatformId: " + PlatformId + ", "
                + "Season: " + Season + ", "
                + "Queue: " + Queue + ", "
                + "Role: " + Role + ", "
                + "Timestamp: " + Timestamp + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchTimeline data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchTimeline
    {
        public MatchTimeline([JsonProperty("frames")] MatchFrame[] frames,
                [JsonProperty("frameInterval")] long frameInterval)
        {
            Frames = frames;
            FrameInterval = frameInterval;
        }
        [JsonProperty("frames")]
        public readonly MatchFrame[] Frames;
        [JsonProperty("frameInterval")]
        public readonly long FrameInterval;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchTimeline"
                + "Frames: " + Frames + ", "
                + "FrameInterval: " + FrameInterval + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchFrame data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchFrame
    {
        public MatchFrame([JsonProperty("timestamp")] long timestamp,
                [JsonProperty("participantFrames")] IDictionary<string, MatchParticipantFrame> participantFrames,
                [JsonProperty("events")] MatchEvent[] events)
        {
            Timestamp = timestamp;
            ParticipantFrames = participantFrames;
            Events = events;
        }
        [JsonProperty("timestamp")]
        public readonly long Timestamp;
        [JsonProperty("participantFrames")]
        public readonly IDictionary<string, MatchParticipantFrame> ParticipantFrames;
        [JsonProperty("events")]
        public readonly MatchEvent[] Events;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchFrame"
                + "Timestamp: " + Timestamp + ", "
                + "ParticipantFrames: " + ParticipantFrames + ", "
                + "Events: " + Events + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchParticipantFrame data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchParticipantFrame
    {
        public MatchParticipantFrame([JsonProperty("totalGold")] int totalGold,
                [JsonProperty("teamScore")] int teamScore,
                [JsonProperty("participantId")] int participantId,
                [JsonProperty("level")] int level,
                [JsonProperty("currentGold")] int currentGold,
                [JsonProperty("minionsKilled")] int minionsKilled,
                [JsonProperty("dominionScore")] int dominionScore,
                [JsonProperty("position")] MatchPosition position,
                [JsonProperty("xp")] int xp,
                [JsonProperty("jungleMinionsKilled")] int jungleMinionsKilled)
        {
            TotalGold = totalGold;
            TeamScore = teamScore;
            ParticipantId = participantId;
            Level = level;
            CurrentGold = currentGold;
            MinionsKilled = minionsKilled;
            DominionScore = dominionScore;
            Position = position;
            Xp = xp;
            JungleMinionsKilled = jungleMinionsKilled;
        }
        [JsonProperty("totalGold")]
        public readonly int TotalGold;
        [JsonProperty("teamScore")]
        public readonly int TeamScore;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;
        [JsonProperty("level")]
        public readonly int Level;
        [JsonProperty("currentGold")]
        public readonly int CurrentGold;
        [JsonProperty("minionsKilled")]
        public readonly int MinionsKilled;
        [JsonProperty("dominionScore")]
        public readonly int DominionScore;
        [JsonProperty("position")]
        public readonly MatchPosition Position;
        [JsonProperty("xp")]
        public readonly int Xp;
        [JsonProperty("jungleMinionsKilled")]
        public readonly int JungleMinionsKilled;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchParticipantFrame"
                + "TotalGold: " + TotalGold + ", "
                + "TeamScore: " + TeamScore + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "Level: " + Level + ", "
                + "CurrentGold: " + CurrentGold + ", "
                + "MinionsKilled: " + MinionsKilled + ", "
                + "DominionScore: " + DominionScore + ", "
                + "Position: " + Position + ", "
                + "Xp: " + Xp + ", "
                + "JungleMinionsKilled: " + JungleMinionsKilled + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchPosition data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchPosition
    {
        public MatchPosition([JsonProperty("y")] int y,
                [JsonProperty("x")] int x)
        {
            Y = y;
            X = x;
        }
        [JsonProperty("y")]
        public readonly int Y;
        [JsonProperty("x")]
        public readonly int X;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchPosition"
                + "Y: " + Y + ", "
                + "X: " + X + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// match-v4
namespace MingweiSamuel.Camille.MatchV4
{
    /// <summary>
    /// MatchEvent data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class MatchEvent
    {
        public MatchEvent([JsonProperty("eventType")] string eventType,
                [JsonProperty("towerType")] string towerType,
                [JsonProperty("teamId")] int teamId,
                [JsonProperty("ascendedType")] string ascendedType,
                [JsonProperty("killerId")] int killerId,
                [JsonProperty("levelUpType")] string levelUpType,
                [JsonProperty("pointCaptured")] string pointCaptured,
                [JsonProperty("assistingParticipantIds")] int[] assistingParticipantIds,
                [JsonProperty("wardType")] string wardType,
                [JsonProperty("monsterType")] string monsterType,
                [JsonProperty("type")] string type,
                [JsonProperty("skillSlot")] int skillSlot,
                [JsonProperty("victimId")] int victimId,
                [JsonProperty("timestamp")] long timestamp,
                [JsonProperty("afterId")] int afterId,
                [JsonProperty("monsterSubType")] string monsterSubType,
                [JsonProperty("laneType")] string laneType,
                [JsonProperty("itemId")] int itemId,
                [JsonProperty("participantId")] int participantId,
                [JsonProperty("buildingType")] string buildingType,
                [JsonProperty("creatorId")] int creatorId,
                [JsonProperty("position")] MatchPosition position,
                [JsonProperty("beforeId")] int beforeId)
        {
            EventType = eventType;
            TowerType = towerType;
            TeamId = teamId;
            AscendedType = ascendedType;
            KillerId = killerId;
            LevelUpType = levelUpType;
            PointCaptured = pointCaptured;
            AssistingParticipantIds = assistingParticipantIds;
            WardType = wardType;
            MonsterType = monsterType;
            Type = type;
            SkillSlot = skillSlot;
            VictimId = victimId;
            Timestamp = timestamp;
            AfterId = afterId;
            MonsterSubType = monsterSubType;
            LaneType = laneType;
            ItemId = itemId;
            ParticipantId = participantId;
            BuildingType = buildingType;
            CreatorId = creatorId;
            Position = position;
            BeforeId = beforeId;
        }
        [JsonProperty("eventType")]
        public readonly string EventType;
        [JsonProperty("towerType")]
        public readonly string TowerType;
        [JsonProperty("teamId")]
        public readonly int TeamId;
        [JsonProperty("ascendedType")]
        public readonly string AscendedType;
        [JsonProperty("killerId")]
        public readonly int KillerId;
        [JsonProperty("levelUpType")]
        public readonly string LevelUpType;
        [JsonProperty("pointCaptured")]
        public readonly string PointCaptured;
        [JsonProperty("assistingParticipantIds")]
        public readonly int[] AssistingParticipantIds;
        [JsonProperty("wardType")]
        public readonly string WardType;
        [JsonProperty("monsterType")]
        public readonly string MonsterType;
        /// <summary>
        /// (Legal values:  CHAMPION_KILL,  WARD_PLACED,  WARD_KILL,  BUILDING_KILL,  ELITE_MONSTER_KILL,  ITEM_PURCHASED,  ITEM_SOLD,  ITEM_DESTROYED,  ITEM_UNDO,  SKILL_LEVEL_UP,  ASCENDED_EVENT,  CAPTURE_POINT,  PORO_KING_SUMMON)
        /// </summary>
        [JsonProperty("type")]
        public readonly string Type;
        [JsonProperty("skillSlot")]
        public readonly int SkillSlot;
        [JsonProperty("victimId")]
        public readonly int VictimId;
        [JsonProperty("timestamp")]
        public readonly long Timestamp;
        [JsonProperty("afterId")]
        public readonly int AfterId;
        [JsonProperty("monsterSubType")]
        public readonly string MonsterSubType;
        [JsonProperty("laneType")]
        public readonly string LaneType;
        [JsonProperty("itemId")]
        public readonly int ItemId;
        [JsonProperty("participantId")]
        public readonly int ParticipantId;
        [JsonProperty("buildingType")]
        public readonly string BuildingType;
        [JsonProperty("creatorId")]
        public readonly int CreatorId;
        [JsonProperty("position")]
        public readonly MatchPosition Position;
        [JsonProperty("beforeId")]
        public readonly int BeforeId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "MatchEvent"
                + "EventType: " + EventType + ", "
                + "TowerType: " + TowerType + ", "
                + "TeamId: " + TeamId + ", "
                + "AscendedType: " + AscendedType + ", "
                + "KillerId: " + KillerId + ", "
                + "LevelUpType: " + LevelUpType + ", "
                + "PointCaptured: " + PointCaptured + ", "
                + "AssistingParticipantIds: " + AssistingParticipantIds + ", "
                + "WardType: " + WardType + ", "
                + "MonsterType: " + MonsterType + ", "
                + "Type: " + Type + ", "
                + "SkillSlot: " + SkillSlot + ", "
                + "VictimId: " + VictimId + ", "
                + "Timestamp: " + Timestamp + ", "
                + "AfterId: " + AfterId + ", "
                + "MonsterSubType: " + MonsterSubType + ", "
                + "LaneType: " + LaneType + ", "
                + "ItemId: " + ItemId + ", "
                + "ParticipantId: " + ParticipantId + ", "
                + "BuildingType: " + BuildingType + ", "
                + "CreatorId: " + CreatorId + ", "
                + "Position: " + Position + ", "
                + "BeforeId: " + BeforeId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// CurrentGameInfo data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class CurrentGameInfo
    {
        public CurrentGameInfo([JsonProperty("gameId")] long gameId,
                [JsonProperty("gameStartTime")] long gameStartTime,
                [JsonProperty("platformId")] string platformId,
                [JsonProperty("gameMode")] string gameMode,
                [JsonProperty("mapId")] long mapId,
                [JsonProperty("gameType")] string gameType,
                [JsonProperty("bannedChampions")] BannedChampion[] bannedChampions,
                [JsonProperty("observers")] Observer observers,
                [JsonProperty("participants")] CurrentGameParticipant[] participants,
                [JsonProperty("gameLength")] long gameLength,
                [JsonProperty("gameQueueConfigId")] long gameQueueConfigId)
        {
            GameId = gameId;
            GameStartTime = gameStartTime;
            PlatformId = platformId;
            GameMode = gameMode;
            MapId = mapId;
            GameType = gameType;
            BannedChampions = bannedChampions;
            Observers = observers;
            Participants = participants;
            GameLength = gameLength;
            GameQueueConfigId = gameQueueConfigId;
        }
        /// <summary>
        /// The ID of the game
        /// </summary>
        [JsonProperty("gameId")]
        public readonly long GameId;
        /// <summary>
        /// The game start time represented in epoch milliseconds
        /// </summary>
        [JsonProperty("gameStartTime")]
        public readonly long GameStartTime;
        /// <summary>
        /// The ID of the platform on which the game is being played
        /// </summary>
        [JsonProperty("platformId")]
        public readonly string PlatformId;
        /// <summary>
        /// The game mode
        /// </summary>
        [JsonProperty("gameMode")]
        public readonly string GameMode;
        /// <summary>
        /// The ID of the map
        /// </summary>
        [JsonProperty("mapId")]
        public readonly long MapId;
        /// <summary>
        /// The game type
        /// </summary>
        [JsonProperty("gameType")]
        public readonly string GameType;
        /// <summary>
        /// Banned champion information
        /// </summary>
        [JsonProperty("bannedChampions")]
        public readonly BannedChampion[] BannedChampions;
        /// <summary>
        /// The observer information
        /// </summary>
        [JsonProperty("observers")]
        public readonly Observer Observers;
        /// <summary>
        /// The participant information
        /// </summary>
        [JsonProperty("participants")]
        public readonly CurrentGameParticipant[] Participants;
        /// <summary>
        /// The amount of time in seconds that has passed since the game started
        /// </summary>
        [JsonProperty("gameLength")]
        public readonly long GameLength;
        /// <summary>
        /// The queue type (queue types are documented on the Game Constants page)
        /// </summary>
        [JsonProperty("gameQueueConfigId")]
        public readonly long GameQueueConfigId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "CurrentGameInfo"
                + "GameId: " + GameId + ", "
                + "GameStartTime: " + GameStartTime + ", "
                + "PlatformId: " + PlatformId + ", "
                + "GameMode: " + GameMode + ", "
                + "MapId: " + MapId + ", "
                + "GameType: " + GameType + ", "
                + "BannedChampions: " + BannedChampions + ", "
                + "Observers: " + Observers + ", "
                + "Participants: " + Participants + ", "
                + "GameLength: " + GameLength + ", "
                + "GameQueueConfigId: " + GameQueueConfigId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// BannedChampion data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class BannedChampion
    {
        public BannedChampion([JsonProperty("pickTurn")] int pickTurn,
                [JsonProperty("championId")] long championId,
                [JsonProperty("teamId")] long teamId)
        {
            PickTurn = pickTurn;
            ChampionId = championId;
            TeamId = teamId;
        }
        /// <summary>
        /// The turn during which the champion was banned
        /// </summary>
        [JsonProperty("pickTurn")]
        public readonly int PickTurn;
        /// <summary>
        /// The ID of the banned champion
        /// </summary>
        [JsonProperty("championId")]
        public readonly long ChampionId;
        /// <summary>
        /// The ID of the team that banned the champion
        /// </summary>
        [JsonProperty("teamId")]
        public readonly long TeamId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "BannedChampion"
                + "PickTurn: " + PickTurn + ", "
                + "ChampionId: " + ChampionId + ", "
                + "TeamId: " + TeamId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// Observer data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Observer
    {
        public Observer([JsonProperty("encryptionKey")] string encryptionKey)
        {
            EncryptionKey = encryptionKey;
        }
        /// <summary>
        /// Key used to decrypt the spectator grid game data for playback
        /// </summary>
        [JsonProperty("encryptionKey")]
        public readonly string EncryptionKey;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Observer"
                + "EncryptionKey: " + EncryptionKey + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// CurrentGameParticipant data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class CurrentGameParticipant
    {
        public CurrentGameParticipant([JsonProperty("profileIconId")] long profileIconId,
                [JsonProperty("championId")] long championId,
                [JsonProperty("summonerName")] string summonerName,
                [JsonProperty("gameCustomizationObjects")] GameCustomizationObject[] gameCustomizationObjects,
                [JsonProperty("bot")] bool bot,
                [JsonProperty("perks")] Perks perks,
                [JsonProperty("spell2Id")] long spell2Id,
                [JsonProperty("teamId")] long teamId,
                [JsonProperty("spell1Id")] long spell1Id,
                [JsonProperty("summonerId")] string summonerId)
        {
            ProfileIconId = profileIconId;
            ChampionId = championId;
            SummonerName = summonerName;
            GameCustomizationObjects = gameCustomizationObjects;
            Bot = bot;
            Perks = perks;
            Spell2Id = spell2Id;
            TeamId = teamId;
            Spell1Id = spell1Id;
            SummonerId = summonerId;
        }
        /// <summary>
        /// The ID of the profile icon used by this participant
        /// </summary>
        [JsonProperty("profileIconId")]
        public readonly long ProfileIconId;
        /// <summary>
        /// The ID of the champion played by this participant
        /// </summary>
        [JsonProperty("championId")]
        public readonly long ChampionId;
        /// <summary>
        /// The summoner name of this participant
        /// </summary>
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        /// <summary>
        /// List of Game Customizations
        /// </summary>
        [JsonProperty("gameCustomizationObjects")]
        public readonly GameCustomizationObject[] GameCustomizationObjects;
        /// <summary>
        /// Flag indicating whether or not this participant is a bot
        /// </summary>
        [JsonProperty("bot")]
        public readonly bool Bot;
        /// <summary>
        /// Perks/Runes Reforged Information
        /// </summary>
        [JsonProperty("perks")]
        public readonly Perks Perks;
        /// <summary>
        /// The ID of the second summoner spell used by this participant
        /// </summary>
        [JsonProperty("spell2Id")]
        public readonly long Spell2Id;
        /// <summary>
        /// The team ID of this participant, indicating the participant's team
        /// </summary>
        [JsonProperty("teamId")]
        public readonly long TeamId;
        /// <summary>
        /// The ID of the first summoner spell used by this participant
        /// </summary>
        [JsonProperty("spell1Id")]
        public readonly long Spell1Id;
        /// <summary>
        /// The encrypted summoner ID of this participant
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "CurrentGameParticipant"
                + "ProfileIconId: " + ProfileIconId + ", "
                + "ChampionId: " + ChampionId + ", "
                + "SummonerName: " + SummonerName + ", "
                + "GameCustomizationObjects: " + GameCustomizationObjects + ", "
                + "Bot: " + Bot + ", "
                + "Perks: " + Perks + ", "
                + "Spell2Id: " + Spell2Id + ", "
                + "TeamId: " + TeamId + ", "
                + "Spell1Id: " + Spell1Id + ", "
                + "SummonerId: " + SummonerId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// GameCustomizationObject data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class GameCustomizationObject
    {
        public GameCustomizationObject([JsonProperty("category")] string category,
                [JsonProperty("content")] string content)
        {
            Category = category;
            Content = content;
        }
        /// <summary>
        /// Category identifier for Game Customization
        /// </summary>
        [JsonProperty("category")]
        public readonly string Category;
        /// <summary>
        /// Game Customization content
        /// </summary>
        [JsonProperty("content")]
        public readonly string Content;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "GameCustomizationObject"
                + "Category: " + Category + ", "
                + "Content: " + Content + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// Perks data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Perks
    {
        public Perks([JsonProperty("perkStyle")] long perkStyle,
                [JsonProperty("perkIds")] long[] perkIds,
                [JsonProperty("perkSubStyle")] long perkSubStyle)
        {
            PerkStyle = perkStyle;
            PerkIds = perkIds;
            PerkSubStyle = perkSubStyle;
        }
        /// <summary>
        /// Primary runes path
        /// </summary>
        [JsonProperty("perkStyle")]
        public readonly long PerkStyle;
        /// <summary>
        /// IDs of the perks/runes assigned.
        /// </summary>
        [JsonProperty("perkIds")]
        public readonly long[] PerkIds;
        /// <summary>
        /// Secondary runes path
        /// </summary>
        [JsonProperty("perkSubStyle")]
        public readonly long PerkSubStyle;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Perks"
                + "PerkStyle: " + PerkStyle + ", "
                + "PerkIds: " + PerkIds + ", "
                + "PerkSubStyle: " + PerkSubStyle + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// FeaturedGames data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class FeaturedGames
    {
        public FeaturedGames([JsonProperty("clientRefreshInterval")] long clientRefreshInterval,
                [JsonProperty("gameList")] FeaturedGameInfo[] gameList)
        {
            ClientRefreshInterval = clientRefreshInterval;
            GameList = gameList;
        }
        /// <summary>
        /// The suggested interval to wait before requesting FeaturedGames again
        /// </summary>
        [JsonProperty("clientRefreshInterval")]
        public readonly long ClientRefreshInterval;
        /// <summary>
        /// The list of featured games
        /// </summary>
        [JsonProperty("gameList")]
        public readonly FeaturedGameInfo[] GameList;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "FeaturedGames"
                + "ClientRefreshInterval: " + ClientRefreshInterval + ", "
                + "GameList: " + GameList + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// FeaturedGameInfo data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class FeaturedGameInfo
    {
        public FeaturedGameInfo([JsonProperty("gameId")] long gameId,
                [JsonProperty("gameStartTime")] long gameStartTime,
                [JsonProperty("platformId")] string platformId,
                [JsonProperty("gameMode")] string gameMode,
                [JsonProperty("mapId")] long mapId,
                [JsonProperty("gameType")] string gameType,
                [JsonProperty("bannedChampions")] BannedChampion[] bannedChampions,
                [JsonProperty("observers")] Observer observers,
                [JsonProperty("participants")] Participant[] participants,
                [JsonProperty("gameLength")] long gameLength,
                [JsonProperty("gameQueueConfigId")] long gameQueueConfigId)
        {
            GameId = gameId;
            GameStartTime = gameStartTime;
            PlatformId = platformId;
            GameMode = gameMode;
            MapId = mapId;
            GameType = gameType;
            BannedChampions = bannedChampions;
            Observers = observers;
            Participants = participants;
            GameLength = gameLength;
            GameQueueConfigId = gameQueueConfigId;
        }
        /// <summary>
        /// The ID of the game
        /// </summary>
        [JsonProperty("gameId")]
        public readonly long GameId;
        /// <summary>
        /// The game start time represented in epoch milliseconds
        /// </summary>
        [JsonProperty("gameStartTime")]
        public readonly long GameStartTime;
        /// <summary>
        /// The ID of the platform on which the game is being played
        /// </summary>
        [JsonProperty("platformId")]
        public readonly string PlatformId;
        /// <summary>
        /// The game mode<para />
        /// (Legal values:  CLASSIC,  ODIN,  ARAM,  TUTORIAL,  ONEFORALL,  ASCENSION,  FIRSTBLOOD,  KINGPORO)
        /// </summary>
        [JsonProperty("gameMode")]
        public readonly string GameMode;
        /// <summary>
        /// The ID of the map
        /// </summary>
        [JsonProperty("mapId")]
        public readonly long MapId;
        /// <summary>
        /// The game type<para />
        /// (Legal values:  CUSTOM_GAME,  MATCHED_GAME,  TUTORIAL_GAME)
        /// </summary>
        [JsonProperty("gameType")]
        public readonly string GameType;
        /// <summary>
        /// Banned champion information
        /// </summary>
        [JsonProperty("bannedChampions")]
        public readonly BannedChampion[] BannedChampions;
        /// <summary>
        /// The observer information
        /// </summary>
        [JsonProperty("observers")]
        public readonly Observer Observers;
        /// <summary>
        /// The participant information
        /// </summary>
        [JsonProperty("participants")]
        public readonly Participant[] Participants;
        /// <summary>
        /// The amount of time in seconds that has passed since the game started
        /// </summary>
        [JsonProperty("gameLength")]
        public readonly long GameLength;
        /// <summary>
        /// The queue type (queue types are documented on the Game Constants page)
        /// </summary>
        [JsonProperty("gameQueueConfigId")]
        public readonly long GameQueueConfigId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "FeaturedGameInfo"
                + "GameId: " + GameId + ", "
                + "GameStartTime: " + GameStartTime + ", "
                + "PlatformId: " + PlatformId + ", "
                + "GameMode: " + GameMode + ", "
                + "MapId: " + MapId + ", "
                + "GameType: " + GameType + ", "
                + "BannedChampions: " + BannedChampions + ", "
                + "Observers: " + Observers + ", "
                + "Participants: " + Participants + ", "
                + "GameLength: " + GameLength + ", "
                + "GameQueueConfigId: " + GameQueueConfigId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// spectator-v4
namespace MingweiSamuel.Camille.SpectatorV4
{
    /// <summary>
    /// Participant data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class Participant
    {
        public Participant([JsonProperty("profileIconId")] long profileIconId,
                [JsonProperty("championId")] long championId,
                [JsonProperty("summonerName")] string summonerName,
                [JsonProperty("bot")] bool bot,
                [JsonProperty("spell2Id")] long spell2Id,
                [JsonProperty("teamId")] long teamId,
                [JsonProperty("spell1Id")] long spell1Id)
        {
            ProfileIconId = profileIconId;
            ChampionId = championId;
            SummonerName = summonerName;
            Bot = bot;
            Spell2Id = spell2Id;
            TeamId = teamId;
            Spell1Id = spell1Id;
        }
        /// <summary>
        /// The ID of the profile icon used by this participant
        /// </summary>
        [JsonProperty("profileIconId")]
        public readonly long ProfileIconId;
        /// <summary>
        /// The ID of the champion played by this participant
        /// </summary>
        [JsonProperty("championId")]
        public readonly long ChampionId;
        /// <summary>
        /// The summoner name of this participant
        /// </summary>
        [JsonProperty("summonerName")]
        public readonly string SummonerName;
        /// <summary>
        /// Flag indicating whether or not this participant is a bot
        /// </summary>
        [JsonProperty("bot")]
        public readonly bool Bot;
        /// <summary>
        /// The ID of the second summoner spell used by this participant
        /// </summary>
        [JsonProperty("spell2Id")]
        public readonly long Spell2Id;
        /// <summary>
        /// The team ID of this participant, indicating the participant's team
        /// </summary>
        [JsonProperty("teamId")]
        public readonly long TeamId;
        /// <summary>
        /// The ID of the first summoner spell used by this participant
        /// </summary>
        [JsonProperty("spell1Id")]
        public readonly long Spell1Id;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Participant"
                + "ProfileIconId: " + ProfileIconId + ", "
                + "ChampionId: " + ChampionId + ", "
                + "SummonerName: " + SummonerName + ", "
                + "Bot: " + Bot + ", "
                + "Spell2Id: " + Spell2Id + ", "
                + "TeamId: " + TeamId + ", "
                + "Spell1Id: " + Spell1Id + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// summoner-v4
namespace MingweiSamuel.Camille.SummonerV4
{
    /// <summary>
    /// Summoner data object. This class is automatically generated.<para />
    /// represents a summoner
    /// </summary>
    public class Summoner
    {
        public Summoner([JsonProperty("profileIconId")] int profileIconId,
                [JsonProperty("name")] string name,
                [JsonProperty("puuid")] string puuid,
                [JsonProperty("summonerLevel")] long summonerLevel,
                [JsonProperty("revisionDate")] long revisionDate,
                [JsonProperty("id")] string id,
                [JsonProperty("accountId")] string accountId)
        {
            ProfileIconId = profileIconId;
            Name = name;
            Puuid = puuid;
            SummonerLevel = summonerLevel;
            RevisionDate = revisionDate;
            Id = id;
            AccountId = accountId;
        }
        /// <summary>
        /// ID of the summoner icon associated with the summoner.
        /// </summary>
        [JsonProperty("profileIconId")]
        public readonly int ProfileIconId;
        /// <summary>
        /// Summoner name.
        /// </summary>
        [JsonProperty("name")]
        public readonly string Name;
        /// <summary>
        /// Encrypted PUUID. Exact length of 78 characters.
        /// </summary>
        [JsonProperty("puuid")]
        public readonly string Puuid;
        /// <summary>
        /// Summoner level associated with the summoner.
        /// </summary>
        [JsonProperty("summonerLevel")]
        public readonly long SummonerLevel;
        /// <summary>
        /// Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: profile icon change, playing the tutorial or advanced tutorial, finishing a game, summoner name change
        /// </summary>
        [JsonProperty("revisionDate")]
        public readonly long RevisionDate;
        /// <summary>
        /// Encrypted summoner ID. Max length 63 characters.
        /// </summary>
        [JsonProperty("id")]
        public readonly string Id;
        /// <summary>
        /// Encrypted account ID. Max length 56 characters.
        /// </summary>
        [JsonProperty("accountId")]
        public readonly string AccountId;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "Summoner"
                + "ProfileIconId: " + ProfileIconId + ", "
                + "Name: " + Name + ", "
                + "Puuid: " + Puuid + ", "
                + "SummonerLevel: " + SummonerLevel + ", "
                + "RevisionDate: " + RevisionDate + ", "
                + "Id: " + Id + ", "
                + "AccountId: " + AccountId + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-stub-v4
namespace MingweiSamuel.Camille.TournamentStubV4
{
    /// <summary>
    /// TournamentCodeParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentCodeParameters
    {
        public TournamentCodeParameters([JsonProperty("spectatorType")] string spectatorType,
                [JsonProperty("teamSize")] int teamSize,
                [JsonProperty("pickType")] string pickType,
                [JsonProperty("allowedSummonerIds")] string[] allowedSummonerIds,
                [JsonProperty("mapType")] string mapType,
                [JsonProperty("metadata")] string metadata)
        {
            SpectatorType = spectatorType;
            TeamSize = teamSize;
            PickType = pickType;
            AllowedSummonerIds = allowedSummonerIds;
            MapType = mapType;
            Metadata = metadata;
        }
        /// <summary>
        /// The spectator type of the game.<para />
        /// (Legal values:  NONE,  LOBBYONLY,  ALL)
        /// </summary>
        [JsonProperty("spectatorType")]
        public readonly string SpectatorType;
        /// <summary>
        /// The team size of the game. Valid values are 1-5.
        /// </summary>
        [JsonProperty("teamSize")]
        public readonly int TeamSize;
        /// <summary>
        /// The pick type of the game.<para />
        /// (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
        /// </summary>
        [JsonProperty("pickType")]
        public readonly string PickType;
        /// <summary>
        /// Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
        /// </summary>
        [JsonProperty("allowedSummonerIds")]
        public readonly string[] AllowedSummonerIds;
        /// <summary>
        /// The map type of the game.<para />
        /// (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
        /// </summary>
        [JsonProperty("mapType")]
        public readonly string MapType;
        /// <summary>
        /// Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
        /// </summary>
        [JsonProperty("metadata")]
        public readonly string Metadata;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentCodeParameters"
                + "SpectatorType: " + SpectatorType + ", "
                + "TeamSize: " + TeamSize + ", "
                + "PickType: " + PickType + ", "
                + "AllowedSummonerIds: " + AllowedSummonerIds + ", "
                + "MapType: " + MapType + ", "
                + "Metadata: " + Metadata + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-stub-v4
namespace MingweiSamuel.Camille.TournamentStubV4
{
    /// <summary>
    /// LobbyEventWrapper data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LobbyEventWrapper
    {
        public LobbyEventWrapper([JsonProperty("eventList")] LobbyEvent[] eventList)
        {
            EventList = eventList;
        }
        [JsonProperty("eventList")]
        public readonly LobbyEvent[] EventList;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LobbyEventWrapper"
                + "EventList: " + EventList + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-stub-v4
namespace MingweiSamuel.Camille.TournamentStubV4
{
    /// <summary>
    /// LobbyEvent data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LobbyEvent
    {
        public LobbyEvent([JsonProperty("eventType")] string eventType,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("timestamp")] string timestamp)
        {
            EventType = eventType;
            SummonerId = summonerId;
            Timestamp = timestamp;
        }
        /// <summary>
        /// The type of event that was triggered
        /// </summary>
        [JsonProperty("eventType")]
        public readonly string EventType;
        /// <summary>
        /// The summonerId that triggered the event (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        /// <summary>
        /// Timestamp from the event
        /// </summary>
        [JsonProperty("timestamp")]
        public readonly string Timestamp;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LobbyEvent"
                + "EventType: " + EventType + ", "
                + "SummonerId: " + SummonerId + ", "
                + "Timestamp: " + Timestamp + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-stub-v4
namespace MingweiSamuel.Camille.TournamentStubV4
{
    /// <summary>
    /// ProviderRegistrationParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ProviderRegistrationParameters
    {
        public ProviderRegistrationParameters([JsonProperty("url")] string url,
                [JsonProperty("region")] string region)
        {
            Url = url;
            Region = region;
        }
        /// <summary>
        /// The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443).
        /// </summary>
        [JsonProperty("url")]
        public readonly string Url;
        /// <summary>
        /// The region in which the provider will be running tournaments.<para />
        /// (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
        /// </summary>
        [JsonProperty("region")]
        public readonly string Region;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ProviderRegistrationParameters"
                + "Url: " + Url + ", "
                + "Region: " + Region + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-stub-v4
namespace MingweiSamuel.Camille.TournamentStubV4
{
    /// <summary>
    /// TournamentRegistrationParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentRegistrationParameters
    {
        public TournamentRegistrationParameters([JsonProperty("providerId")] int providerId,
                [JsonProperty("name")] string name)
        {
            ProviderId = providerId;
            Name = name;
        }
        /// <summary>
        /// The provider ID to specify the regional registered provider data to associate this tournament.
        /// </summary>
        [JsonProperty("providerId")]
        public readonly int ProviderId;
        /// <summary>
        /// The optional name of the tournament.
        /// </summary>
        [JsonProperty("name")]
        public readonly string Name;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentRegistrationParameters"
                + "ProviderId: " + ProviderId + ", "
                + "Name: " + Name + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// TournamentCodeParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentCodeParameters
    {
        public TournamentCodeParameters([JsonProperty("spectatorType")] string spectatorType,
                [JsonProperty("teamSize")] int teamSize,
                [JsonProperty("pickType")] string pickType,
                [JsonProperty("allowedSummonerIds")] string[] allowedSummonerIds,
                [JsonProperty("mapType")] string mapType,
                [JsonProperty("metadata")] string metadata)
        {
            SpectatorType = spectatorType;
            TeamSize = teamSize;
            PickType = pickType;
            AllowedSummonerIds = allowedSummonerIds;
            MapType = mapType;
            Metadata = metadata;
        }
        /// <summary>
        /// The spectator type of the game.<para />
        /// (Legal values:  NONE,  LOBBYONLY,  ALL)
        /// </summary>
        [JsonProperty("spectatorType")]
        public readonly string SpectatorType;
        /// <summary>
        /// The team size of the game. Valid values are 1-5.
        /// </summary>
        [JsonProperty("teamSize")]
        public readonly int TeamSize;
        /// <summary>
        /// The pick type of the game.<para />
        /// (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
        /// </summary>
        [JsonProperty("pickType")]
        public readonly string PickType;
        /// <summary>
        /// Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
        /// </summary>
        [JsonProperty("allowedSummonerIds")]
        public readonly string[] AllowedSummonerIds;
        /// <summary>
        /// The map type of the game.<para />
        /// (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
        /// </summary>
        [JsonProperty("mapType")]
        public readonly string MapType;
        /// <summary>
        /// Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
        /// </summary>
        [JsonProperty("metadata")]
        public readonly string Metadata;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentCodeParameters"
                + "SpectatorType: " + SpectatorType + ", "
                + "TeamSize: " + TeamSize + ", "
                + "PickType: " + PickType + ", "
                + "AllowedSummonerIds: " + AllowedSummonerIds + ", "
                + "MapType: " + MapType + ", "
                + "Metadata: " + Metadata + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// TournamentCode data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentCode
    {
        public TournamentCode([JsonProperty("map")] string map,
                [JsonProperty("code")] string code,
                [JsonProperty("spectators")] string spectators,
                [JsonProperty("region")] string region,
                [JsonProperty("providerId")] int providerId,
                [JsonProperty("teamSize")] int teamSize,
                [JsonProperty("participants")] string[] participants,
                [JsonProperty("pickType")] string pickType,
                [JsonProperty("tournamentId")] int tournamentId,
                [JsonProperty("lobbyName")] string lobbyName,
                [JsonProperty("password")] string password,
                [JsonProperty("id")] int id,
                [JsonProperty("metaData")] string metaData)
        {
            Map = map;
            Code = code;
            Spectators = spectators;
            Region = region;
            ProviderId = providerId;
            TeamSize = teamSize;
            Participants = participants;
            PickType = pickType;
            TournamentId = tournamentId;
            LobbyName = lobbyName;
            Password = password;
            Id = id;
            MetaData = metaData;
        }
        /// <summary>
        /// The game map for the tournament code game
        /// </summary>
        [JsonProperty("map")]
        public readonly string Map;
        /// <summary>
        /// The tournament code.
        /// </summary>
        [JsonProperty("code")]
        public readonly string Code;
        /// <summary>
        /// The spectator mode for the tournament code game.
        /// </summary>
        [JsonProperty("spectators")]
        public readonly string Spectators;
        /// <summary>
        /// The tournament code's region.<para />
        /// (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
        /// </summary>
        [JsonProperty("region")]
        public readonly string Region;
        /// <summary>
        /// The provider's ID.
        /// </summary>
        [JsonProperty("providerId")]
        public readonly int ProviderId;
        /// <summary>
        /// The team size for the tournament code game.
        /// </summary>
        [JsonProperty("teamSize")]
        public readonly int TeamSize;
        /// <summary>
        /// The summonerIds of the participants (Encrypted)
        /// </summary>
        [JsonProperty("participants")]
        public readonly string[] Participants;
        /// <summary>
        /// The pick mode for tournament code game.
        /// </summary>
        [JsonProperty("pickType")]
        public readonly string PickType;
        /// <summary>
        /// The tournament's ID.
        /// </summary>
        [JsonProperty("tournamentId")]
        public readonly int TournamentId;
        /// <summary>
        /// The lobby name for the tournament code game.
        /// </summary>
        [JsonProperty("lobbyName")]
        public readonly string LobbyName;
        /// <summary>
        /// The password for the tournament code game.
        /// </summary>
        [JsonProperty("password")]
        public readonly string Password;
        /// <summary>
        /// The tournament code's ID.
        /// </summary>
        [JsonProperty("id")]
        public readonly int Id;
        /// <summary>
        /// The metadata for tournament code.
        /// </summary>
        [JsonProperty("metaData")]
        public readonly string MetaData;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentCode"
                + "Map: " + Map + ", "
                + "Code: " + Code + ", "
                + "Spectators: " + Spectators + ", "
                + "Region: " + Region + ", "
                + "ProviderId: " + ProviderId + ", "
                + "TeamSize: " + TeamSize + ", "
                + "Participants: " + Participants + ", "
                + "PickType: " + PickType + ", "
                + "TournamentId: " + TournamentId + ", "
                + "LobbyName: " + LobbyName + ", "
                + "Password: " + Password + ", "
                + "Id: " + Id + ", "
                + "MetaData: " + MetaData + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// TournamentCodeUpdateParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentCodeUpdateParameters
    {
        public TournamentCodeUpdateParameters([JsonProperty("spectatorType")] string spectatorType,
                [JsonProperty("pickType")] string pickType,
                [JsonProperty("allowedSummonerIds")] string[] allowedSummonerIds,
                [JsonProperty("mapType")] string mapType)
        {
            SpectatorType = spectatorType;
            PickType = pickType;
            AllowedSummonerIds = allowedSummonerIds;
            MapType = mapType;
        }
        /// <summary>
        /// The spectator type<para />
        /// (Legal values:  NONE,  LOBBYONLY,  ALL)
        /// </summary>
        [JsonProperty("spectatorType")]
        public readonly string SpectatorType;
        /// <summary>
        /// The pick type<para />
        /// (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
        /// </summary>
        [JsonProperty("pickType")]
        public readonly string PickType;
        /// <summary>
        /// Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
        /// </summary>
        [JsonProperty("allowedSummonerIds")]
        public readonly string[] AllowedSummonerIds;
        /// <summary>
        /// The map type<para />
        /// (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
        /// </summary>
        [JsonProperty("mapType")]
        public readonly string MapType;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentCodeUpdateParameters"
                + "SpectatorType: " + SpectatorType + ", "
                + "PickType: " + PickType + ", "
                + "AllowedSummonerIds: " + AllowedSummonerIds + ", "
                + "MapType: " + MapType + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// LobbyEventWrapper data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LobbyEventWrapper
    {
        public LobbyEventWrapper([JsonProperty("eventList")] LobbyEvent[] eventList)
        {
            EventList = eventList;
        }
        [JsonProperty("eventList")]
        public readonly LobbyEvent[] EventList;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LobbyEventWrapper"
                + "EventList: " + EventList + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// LobbyEvent data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class LobbyEvent
    {
        public LobbyEvent([JsonProperty("timestamp")] string timestamp,
                [JsonProperty("summonerId")] string summonerId,
                [JsonProperty("eventType")] string eventType)
        {
            Timestamp = timestamp;
            SummonerId = summonerId;
            EventType = eventType;
        }
        /// <summary>
        /// Timestamp from the event
        /// </summary>
        [JsonProperty("timestamp")]
        public readonly string Timestamp;
        /// <summary>
        /// The summonerId that triggered the event (Encrypted)
        /// </summary>
        [JsonProperty("summonerId")]
        public readonly string SummonerId;
        /// <summary>
        /// The type of event that was triggered
        /// </summary>
        [JsonProperty("eventType")]
        public readonly string EventType;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "LobbyEvent"
                + "Timestamp: " + Timestamp + ", "
                + "SummonerId: " + SummonerId + ", "
                + "EventType: " + EventType + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// ProviderRegistrationParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class ProviderRegistrationParameters
    {
        public ProviderRegistrationParameters([JsonProperty("url")] string url,
                [JsonProperty("region")] string region)
        {
            Url = url;
            Region = region;
        }
        /// <summary>
        /// The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443).
        /// </summary>
        [JsonProperty("url")]
        public readonly string Url;
        /// <summary>
        /// The region in which the provider will be running tournaments.<para />
        /// (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
        /// </summary>
        [JsonProperty("region")]
        public readonly string Region;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "ProviderRegistrationParameters"
                + "Url: " + Url + ", "
                + "Region: " + Region + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

// tournament-v4
namespace MingweiSamuel.Camille.TournamentV4
{
    /// <summary>
    /// TournamentRegistrationParameters data object. This class is automatically generated.<para />
    /// 
    /// </summary>
    public class TournamentRegistrationParameters
    {
        public TournamentRegistrationParameters([JsonProperty("providerId")] int providerId,
                [JsonProperty("name")] string name)
        {
            ProviderId = providerId;
            Name = name;
        }
        /// <summary>
        /// The provider ID to specify the regional registered provider data to associate this tournament.
        /// </summary>
        [JsonProperty("providerId")]
        public readonly int ProviderId;
        /// <summary>
        /// The optional name of the tournament.
        /// </summary>
        [JsonProperty("name")]
        public readonly string Name;

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public readonly Dictionary<string, JToken> _AdditionalProperties = new Dictionary<string, JToken>();

        public override string ToString()
        {
            return "TournamentRegistrationParameters"
                + "ProviderId: " + ProviderId + ", "
                + "Name: " + Name + ", "
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

#endregion
